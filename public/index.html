<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sicherer Chat V2 - Fixed</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom Scrollbar f√ºr h√ºbschere UI */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #f1f1f1; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    
    .message-bubble {
        position: relative;
        transition: all 0.2s;
    }
    .reaction-bar {
        margin-top: 4px;
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        justify-content: flex-end;
    }
    .menu-popup {
        animation: fadeIn 0.1s ease-out;
    }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    
    // WebSocket Setup
    let ws = null;
    
    const connectWebSocket = (onMessage) => {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}`);
      
      ws.onopen = () => console.log('‚úÖ WebSocket verbunden');
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        onMessage(data);
      };
      ws.onerror = (error) => console.error('‚ùå WebSocket Fehler:', error);
      ws.onclose = () => {
        // Silent Reconnect
        setTimeout(() => connectWebSocket(onMessage), 3000);
      };
      
      return ws;
    };
    
    // Storage API Wrapper
    window.storage = {
      async get(key, shared = false) {
        try {
          const response = await fetch(`/api/storage/${key}?shared=${shared}`);
          if (!response.ok) throw new Error('Key not found');
          return await response.json();
        } catch (e) {
          throw e;
        }
      },
      async set(key, value, shared = false) {
        const response = await fetch(`/api/storage/${key}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ value, shared })
        });
        return await response.json();
      }
    };

    // ============================================
    // üîê CRYPTO UTILS (Unver√§ndert stabil)
    // ============================================
    const deriveKeyFromPassword = async (password, salt) => {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']
      );
      return await crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: salt, iterations: 300000, hash: 'SHA-256' },
        keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']
      );
    };

    const generateUserKeypair = async () => {
      return await crypto.subtle.generateKey(
        { name: 'RSA-OAEP', modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: 'SHA-256' },
        true, ['encrypt', 'decrypt']
      );
    };

    const encryptPrivateKey = async (privateKey, password) => {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const key = await deriveKeyFromPassword(password, salt);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const exported = await crypto.subtle.exportKey('pkcs8', privateKey);
      const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, exported);
      const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
      result.set(salt, 0); result.set(iv, salt.length); result.set(new Uint8Array(encrypted), salt.length + iv.length);
      return btoa(String.fromCharCode(...result));
    };

    const decryptPrivateKey = async (encryptedData, password) => {
      const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
      const salt = data.slice(0, 16);
      const iv = data.slice(16, 28);
      const encrypted = data.slice(28);
      const key = await deriveKeyFromPassword(password, salt);
      const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);
      return await crypto.subtle.importKey('pkcs8', decrypted, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['decrypt']);
    };

    const exportPublicKey = async (publicKey) => {
      const exported = await crypto.subtle.exportKey('spki', publicKey);
      return btoa(String.fromCharCode(...new Uint8Array(exported)));
    };

    const importPublicKey = async (keyData) => {
      const binary = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
      return await crypto.subtle.importKey('spki', binary, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
    };

    const encryptMessage = async (text, recipientPublicKey) => {
      const sessionKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, sessionKey, enc.encode(text));
      const exportedSessionKey = await crypto.subtle.exportKey('raw', sessionKey);
      const encryptedSessionKey = await crypto.subtle.encrypt({ name: 'RSA-OAEP' }, recipientPublicKey, exportedSessionKey);
      return {
        ciphertext: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
        iv: btoa(String.fromCharCode(...iv)),
        encryptedSessionKey: btoa(String.fromCharCode(...new Uint8Array(encryptedSessionKey)))
      };
    };

    const decryptMessage = async (encrypted, privateKey) => {
      try {
        const encryptedSessionKeyData = Uint8Array.from(atob(encrypted.encryptedSessionKey), c => c.charCodeAt(0));
        const sessionKeyData = await crypto.subtle.decrypt({ name: 'RSA-OAEP' }, privateKey, encryptedSessionKeyData);
        const sessionKey = await crypto.subtle.importKey('raw', sessionKeyData, { name: 'AES-GCM', length: 256 }, false, ['decrypt']);
        const iv = Uint8Array.from(atob(encrypted.iv), c => c.charCodeAt(0));
        const ciphertext = Uint8Array.from(atob(encrypted.ciphertext), c => c.charCodeAt(0));
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, sessionKey, ciphertext);
        return new TextDecoder().decode(decrypted);
      } catch (e) {
        return '[Entschl√ºsselung fehlgeschlagen]';
      }
    };

    // Icons
    const Icons = {
        Lock: () => <svg className="w-12 h-12 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>,
        Send: () => <svg className="w-5 h-5 transform rotate-90" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>,
        Search: () => <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>,
        X: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
        Smile: () => <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        Check: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" /></svg>,
        Settings: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
        Trash: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
        More: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" /></svg>
    };

    const EncryptedChat = () => {
      const [isLoggedIn, setIsLoggedIn] = useState(false);
      const [username, setUsername] = useState('');
      const [password, setPassword] = useState('');
      const [currentUser, setCurrentUser] = useState('');
      const [privateKey, setPrivateKey] = useState(null);
      const [currentChat, setCurrentChat] = useState(null);
      const [message, setMessage] = useState('');
      const [chats, setChats] = useState([]);
      const [messages, setMessages] = useState({});
      const [error, setError] = useState('');
      const [onlineUsers, setOnlineUsers] = useState([]);
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const [chatRequests, setChatRequests] = useState([]);
      const [pendingRequests, setPendingRequests] = useState([]);
      const [selectedMessage, setSelectedMessage] = useState(null);
      const [typingUsers, setTypingUsers] = useState({});
      const [showSettings, setShowSettings] = useState(false);
      const [isSending, setIsSending] = useState(false);
      const [unreadCounts, setUnreadCounts] = useState({});
      const [activeTab, setActiveTab] = useState(true);

      const messagesEndRef = useRef(null);
      const wsRef = useRef(null);
      // Ref um sicherzustellen, dass wir nicht in unmounted components schreiben
      const currentChatRef = useRef(null);

      const emojis = ['üòÄ', 'üòÇ', 'üòç', 'ü•∞', 'üòé', 'ü§î', 'üëç', 'üëè', 'üéâ', '‚ù§Ô∏è', 'üî•', '‚ú®', 'üíØ', 'üöÄ', '‚≠ê', 'üí™'];
      const reactionEmojis = ['‚ù§Ô∏è', 'üòÇ', 'üëç', 'üî•', 'üéâ', 'üòÆ', '‚ùì'];

      // Pr√§senz-Erkennung
      useEffect(() => {
        const onFocus = () => { setActiveTab(true); sendStatus('online'); };
        const onBlur = () => { setActiveTab(false); sendStatus('away'); };
        
        window.addEventListener('focus', onFocus);
        window.addEventListener('blur', onBlur);
        
        return () => {
            window.removeEventListener('focus', onFocus);
            window.removeEventListener('blur', onBlur);
        };
      }, [isLoggedIn, currentUser]);

      const sendStatus = (status) => {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN && currentUser) {
            wsRef.current.send(JSON.stringify({ type: 'status', user: currentUser, status }));
        }
      };

      // WebSocket Connection Setup
      useEffect(() => {
        if (currentUser) {
            loadUserData();
            loadChatRequests();
        }
        
        wsRef.current = connectWebSocket((data) => {
          if (data.type === 'users_update') {
            setOnlineUsers(data.users);
          }
          if (data.type === 'new_message') {
             // Sofortiges Update triggern, auch wenn wir nicht im Chat sind
             checkAllUnread();
             
             // Wenn wir im Chat sind, Nachrichten laden
             if (currentChatRef.current && data.chat.includes(currentChatRef.current)) {
                loadMessagesForChat(currentChatRef.current);
             }
          }
          if (data.type === 'chat_request') {
            loadChatRequests();
            loadUserData();
          }
          if (data.type === 'chat_accepted') {
             // Delay damit Storage syncen kann
             setTimeout(() => {
                 loadUserData(); 
                 loadChatRequests();
             }, 500);
          }
          if (data.type === 'chat_declined') {
            loadChatRequests();
            loadUserData();
          }
          if (data.type === 'typing' && data.chat.includes(currentUser)) {
             // Extract who is typing
             const typer = data.user;
             if (typer !== currentUser) {
                setTypingUsers(prev => ({ ...prev, [typer]: true }));
                setTimeout(() => {
                    setTypingUsers(prev => {
                        const next = { ...prev };
                        delete next[typer];
                        return next;
                    });
                }, 3000);
             }
          }
        });

        ws = wsRef.current;

        return () => {
          if (wsRef.current) wsRef.current.close();
        };
      }, [currentUser]);

      // Polling Logic: Alle 1 Sekunde Badges checken
      useEffect(() => {
        if (!isLoggedIn || !currentUser) return;

        const interval = setInterval(() => {
            checkAllUnread();
            loadChatRequests();
            // Wenn Chat offen ist, auch Nachrichten polliing (Sicherheit)
            if (currentChatRef.current) {
                loadMessagesForChat(currentChatRef.current);
            }
        }, 1000);

        return () => clearInterval(interval);
      }, [isLoggedIn, currentUser, chats]);

      // Scroll to bottom logic
      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages, currentChat]);

      // Update Ref when Chat changes
      useEffect(() => {
          currentChatRef.current = currentChat;
          if (currentChat) {
              // Reset unread count for this chat locally
              setUnreadCounts(prev => ({...prev, [currentChat]: 0}));
              // Save "read" state
              updateReadCount(currentChat);
          }
      }, [currentChat]);

      const loadUserData = async () => {
        if (!currentUser) return;
        try {
          const result = await window.storage.get('chats_' + currentUser, true);
          setChats(JSON.parse(result.value));
        } catch (e) {
          setChats([]);
        }
      };

      const loadChatRequests = async () => {
        if (!currentUser) return;
        try {
          const result = await window.storage.get('requests_' + currentUser, true);
          setChatRequests(JSON.parse(result.value));
          const pendingRes = await window.storage.get('pending_' + currentUser, true);
          setPendingRequests(JSON.parse(pendingRes.value));
        } catch (e) {}
      };

      // Check for unread messages across ALL chats
      const checkAllUnread = async () => {
        if (!chats || chats.length === 0) return;
        
        const newUnread = {};
        for (const chatUser of chats) {
            // Nur checken wenn nicht der aktive Chat
            if (chatUser === currentChatRef.current) continue;

            const chatId = [currentUser, chatUser].sort().join('_');
            try {
                // Nur Metadaten/L√§nge holen w√§re effizienter, aber hier laden wir das Array
                const result = await window.storage.get(`messages_${chatId}`, true);
                const allMsgs = JSON.parse(result.value);
                
                // Hole den gespeicherten "Gelesen" Z√§hler
                const lastReadStr = localStorage.getItem(`readCount_${currentUser}_${chatUser}`);
                const lastRead = lastReadStr ? parseInt(lastReadStr) : 0;
                
                if (allMsgs.length > lastRead) {
                    newUnread[chatUser] = allMsgs.length - lastRead;
                }
            } catch(e) {}
        }
        setUnreadCounts(prev => ({...prev, ...newUnread}));
      };

      const updateReadCount = async (chatUser) => {
          const chatId = [currentUser, chatUser].sort().join('_');
          try {
              const result = await window.storage.get(`messages_${chatId}`, true);
              const msgs = JSON.parse(result.value);
              localStorage.setItem(`readCount_${currentUser}_${chatUser}`, msgs.length);
              setUnreadCounts(prev => ({...prev, [chatUser]: 0}));
          } catch(e) {}
      };

      const loadMessagesForChat = async (chatUser) => {
        if (!chatUser || !privateKey) return;
        
        const chatId = [currentUser, chatUser].sort().join('_');
        try {
          const result = await window.storage.get(`messages_${chatId}`, true);
          const rawMessages = JSON.parse(result.value);
          
          // Entschl√ºsseln
          const decryptedMessages = await Promise.all(
            rawMessages.map(async msg => {
              if (msg.deleted) return { ...msg, text: 'üóëÔ∏è Nachricht gel√∂scht' };

              let decryptedText = '';
              try {
                if (msg.user !== currentUser && msg.encryptedData) {
                    decryptedText = await decryptMessage(msg.encryptedData, privateKey);
                } else if (msg.user === currentUser && msg.encryptedForSender) {
                    decryptedText = await decryptMessage(msg.encryptedForSender, privateKey);
                } else {
                    decryptedText = '[Fehler]';
                }
              } catch (e) { decryptedText = 'üîí ...'; }
              
              return { ...msg, text: decryptedText };
            })
          );
          
          // BUGFIX: √úberpr√ºfen, ob wir noch im selben Chat sind (gegen Race Conditions)
          if (currentChatRef.current === chatUser) {
              setMessages(prev => ({ ...prev, [chatUser]: decryptedMessages }));
              // Update read count
              localStorage.setItem(`readCount_${currentUser}_${chatUser}`, rawMessages.length);
          }
          
        } catch (e) {
          if (currentChatRef.current === chatUser) {
             setMessages(prev => ({ ...prev, [chatUser]: [] }));
          }
        }
      };

      // AUTHENTICATION
      const handleAuth = async () => {
        setError('');
        if (!username || !password) return setError('Bitte alles ausf√ºllen');
        if (username.length < 3) return setError('Name zu kurz');
        
        try {
          // Mock Auth - Key Generierung oder Login
          let userData = {};
          try {
            const result = await window.storage.get('userdata_' + username, true);
            userData = JSON.parse(result.value);
          } catch (e) {
            // Register
            const keypair = await generateUserKeypair();
            const encryptedPrivKey = await encryptPrivateKey(keypair.privateKey, password);
            const publicKey = await exportPublicKey(keypair.publicKey);
            userData = { encryptedPrivateKey: encryptedPrivKey, publicKey: publicKey };
            await window.storage.set('userdata_' + username, JSON.stringify(userData), true);
            
            // Add to global list
            try {
                const uRes = await window.storage.get('all_users', true);
                const all = JSON.parse(uRes.value);
                if(!all.includes(username)) await window.storage.set('all_users', JSON.stringify([...all, username]), true);
            } catch(e) { await window.storage.set('all_users', JSON.stringify([username]), true); }
          }

          // Login
          const privKey = await decryptPrivateKey(userData.encryptedPrivateKey, password);
          setPrivateKey(privKey);
          setCurrentUser(username);
          setIsLoggedIn(true);
          
          // Initial Load
          loadUserData();
        } catch (e) {
          setError('Falsches Passwort oder Fehler');
        }
      };

      const handleSendMessage = async () => {
        const textToSend = message; // Capture current text
        if (!textToSend.trim() || !currentChat || !privateKey || isSending) return;

        // UI Optimierung: Sofort leeren
        setMessage('');
        setIsSending(true);
        setShowEmojiPicker(false);

        try {
          const myData = await window.storage.get('userdata_' + currentUser, true);
          const myPub = await importPublicKey(JSON.parse(myData.value).publicKey);
          const recData = await window.storage.get('userdata_' + currentChat, true);
          const recPub = await importPublicKey(JSON.parse(recData.value).publicKey);

          const encryptedForRec = await encryptMessage(textToSend, recPub);
          const encryptedForMe = await encryptMessage(textToSend, myPub);

          const newMessage = {
            id: Date.now() + Math.random().toString(),
            user: currentUser,
            encryptedData: encryptedForRec,
            encryptedForSender: encryptedForMe,
            reactions: {},
            timestamp: new Date().toISOString()
          };

          const chatId = [currentUser, currentChat].sort().join('_');
          let existing = [];
          try {
             const res = await window.storage.get(`messages_${chatId}`, true);
             existing = JSON.parse(res.value);
          } catch(e) {}
          
          existing.push(newMessage);
          await window.storage.set(`messages_${chatId}`, JSON.stringify(existing), true);

          if (wsRef.current) wsRef.current.send(JSON.stringify({ type: 'new_message', chat: chatId }));
          
          // Reload
          await loadMessagesForChat(currentChat);
        } catch (e) {
          setError('Senden fehlgeschlagen');
          setMessage(textToSend); // Restore text on fail
        } finally {
            setIsSending(false);
        }
      };

      const deleteMessage = async (msgId) => {
          if (!currentChat) return;
          if (!confirm("Nachricht wirklich l√∂schen?")) return;

          const chatId = [currentUser, currentChat].sort().join('_');
          try {
              const res = await window.storage.get(`messages_${chatId}`, true);
              let all = JSON.parse(res.value);
              // Markieren als gel√∂scht statt komplett entfernen, um Sync-Probleme zu vermeiden
              // oder komplett entfernen (hier markieren wir es, damit der andere sieht dass es weg ist)
              all = all.map(m => {
                  if (m.id === msgId) return { ...m, deleted: true, encryptedData: null, encryptedForSender: null };
                  return m;
              });
              
              await window.storage.set(`messages_${chatId}`, JSON.stringify(all), true);
              if (wsRef.current) wsRef.current.send(JSON.stringify({ type: 'new_message', chat: chatId }));
              loadMessagesForChat(currentChat);
              setSelectedMessage(null);
          } catch(e) {}
      };

      const addReaction = async (messageId, emoji) => {
        if (!currentChat) return;
        const chatId = [currentUser, currentChat].sort().join('_');
        try {
            const res = await window.storage.get(`messages_${chatId}`, true);
            let all = JSON.parse(res.value);
            const idx = all.findIndex(m => m.id === messageId);
            
            if (idx !== -1) {
                if (!all[idx].reactions) all[idx].reactions = {};
                if (!all[idx].reactions[emoji]) all[idx].reactions[emoji] = [];
                
                const uIdx = all[idx].reactions[emoji].indexOf(currentUser);
                if (uIdx === -1) all[idx].reactions[emoji].push(currentUser);
                else {
                    all[idx].reactions[emoji].splice(uIdx, 1);
                    if(all[idx].reactions[emoji].length === 0) delete all[idx].reactions[emoji];
                }
                
                await window.storage.set(`messages_${chatId}`, JSON.stringify(all), true);
                if (wsRef.current) wsRef.current.send(JSON.stringify({ type: 'new_message', chat: chatId }));
                loadMessagesForChat(currentChat);
            }
        } catch(e) {}
        setSelectedMessage(null);
      };

      const handleTyping = () => {
          if(wsRef.current && currentChat) {
              const chatId = [currentUser, currentChat].sort().join('_');
              wsRef.current.send(JSON.stringify({ type: 'typing', chat: chatId, user: currentUser }));
          }
      };

      // Search & Request Logic (Vereinfacht f√ºr L√§nge)
      const searchUsers = async (q) => {
          setSearchQuery(q);
          if(!q.trim()) return setSearchResults([]);
          try {
              const res = await window.storage.get('all_users', true);
              const all = JSON.parse(res.value);
              setSearchResults(all.filter(u => u.toLowerCase().includes(q.toLowerCase()) && u !== currentUser));
          } catch(e) {}
      };

      const sendChatRequest = async (target) => {
          try {
             // Load existing
             let reqs = []; 
             try { const r = await window.storage.get('requests_'+target, true); reqs = JSON.parse(r.value); } catch(e){}
             if(!reqs.includes(currentUser)) {
                 reqs.push(currentUser);
                 await window.storage.set('requests_'+target, JSON.stringify(reqs), true);
             }
             // My pending
             let pen = [...pendingRequests];
             if(!pen.includes(target)) {
                 pen.push(target);
                 setPendingRequests(pen);
                 await window.storage.set('pending_'+currentUser, JSON.stringify(pen), true);
             }
             if(wsRef.current) wsRef.current.send(JSON.stringify({ type: 'chat_request' }));
             setSearchQuery('');
          } catch(e) {}
      };

      const acceptRequest = async (requester) => {
          // Update my chats
          let myChats = [...chats];
          if(!myChats.includes(requester)) {
              myChats.push(requester);
              setChats(myChats);
              await window.storage.set('chats_'+currentUser, JSON.stringify(myChats), true);
          }
          // Update their chats
          try {
              let theirChats = [];
              try { const r = await window.storage.get('chats_'+requester, true); theirChats = JSON.parse(r.value); } catch(e){}
              if(!theirChats.includes(currentUser)) {
                  theirChats.push(currentUser);
                  await window.storage.set('chats_'+requester, JSON.stringify(theirChats), true);
              }
          } catch(e){}
          // Remove Request
          const newReqs = chatRequests.filter(r => r !== requester);
          setChatRequests(newReqs);
          await window.storage.set('requests_'+currentUser, JSON.stringify(newReqs), true);
          // Notify
          if(wsRef.current) wsRef.current.send(JSON.stringify({ type: 'chat_accepted' }));
      };

      if (!isLoggedIn) {
        return (
          <div className="h-screen bg-slate-900 flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md border border-slate-700">
              <div className="flex justify-center mb-6"><Icons.Lock /></div>
              <h1 className="text-2xl font-bold text-center mb-2 text-slate-800">Secure Chat V2</h1>
              <div className="space-y-4">
                <input type="text" value={username} onChange={e => setUsername(e.target.value)} 
                       className="w-full px-4 py-3 border rounded-xl bg-slate-50 focus:ring-2 focus:ring-blue-500 outline-none" 
                       placeholder="Benutzername" />
                <input type="password" value={password} onChange={e => setPassword(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleAuth()}
                       className="w-full px-4 py-3 border rounded-xl bg-slate-50 focus:ring-2 focus:ring-blue-500 outline-none" 
                       placeholder="Passwort" />
                {error && <div className="text-red-500 text-sm text-center bg-red-50 p-2 rounded">{error}</div>}
                <button onClick={handleAuth} className="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-xl font-bold transition">Starten</button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="h-screen flex bg-slate-100 overflow-hidden">
          {/* Sidebar */}
          <div className="w-80 bg-white border-r border-gray-200 flex flex-col z-20 shadow-lg">
            <div className="p-4 border-b bg-gray-50">
              <div className="flex justify-between items-center mb-4">
                 <div className="font-bold text-lg text-slate-700 flex items-center gap-2">
                    <div className={`w-3 h-3 rounded-full ${activeTab ? 'bg-green-500' : 'bg-yellow-500'}`}></div>
                    {currentUser}
                 </div>
                 <button onClick={() => setIsLoggedIn(false)} className="text-xs bg-red-100 text-red-600 px-2 py-1 rounded hover:bg-red-200">Logout</button>
              </div>
              <div className="relative">
                <input type="text" value={searchQuery} onChange={e => searchUsers(e.target.value)} placeholder="User suchen..." 
                       className="w-full pl-9 pr-4 py-2 bg-white border border-gray-300 rounded-lg text-sm focus:outline-none focus:border-blue-500" />
                <div className="absolute left-2.5 top-2.5"><Icons.Search /></div>
              </div>
              {/* Search Results */}
              {searchQuery && (
                  <div className="absolute mt-1 w-72 bg-white shadow-xl border rounded-lg max-h-48 overflow-y-auto z-50">
                      {searchResults.map(u => (
                          <div key={u} onClick={() => !chats.includes(u) && sendChatRequest(u)} 
                               className="p-3 hover:bg-blue-50 cursor-pointer flex justify-between items-center border-b">
                               <span>{u}</span>
                               {chats.includes(u) ? <Icons.Check /> : pendingRequests.includes(u) ? <span className="text-xs text-orange-500">Warten...</span> : <span className="text-xs text-blue-500">+ Add</span>}
                          </div>
                      ))}
                  </div>
              )}
            </div>

            {/* Chat Requests */}
            {chatRequests.length > 0 && (
                <div className="bg-blue-50 p-2 border-b">
                    <p className="text-xs font-bold text-blue-800 mb-1 px-2">Anfragen</p>
                    {chatRequests.map(r => (
                        <div key={r} className="flex justify-between items-center bg-white p-2 rounded mb-1 shadow-sm">
                            <span className="text-sm">{r}</span>
                            <div className="flex gap-1">
                                <button onClick={() => acceptRequest(r)} className="text-green-600 hover:bg-green-100 p-1 rounded"><Icons.Check/></button>
                            </div>
                        </div>
                    ))}
                </div>
            )}

            {/* Chat List */}
            <div className="flex-1 overflow-y-auto">
              {chats.map(chat => (
                <div key={chat} onClick={() => setCurrentChat(chat)} 
                     className={`p-4 border-b cursor-pointer transition hover:bg-gray-50 flex items-center justify-between ${currentChat === chat ? 'bg-blue-50 border-l-4 border-l-blue-500' : ''}`}>
                   <div className="flex items-center gap-3">
                       <div className="relative">
                           <div className="w-10 h-10 rounded-full bg-gradient-to-tr from-blue-500 to-purple-600 text-white flex items-center justify-center font-bold">
                               {chat[0].toUpperCase()}
                           </div>
                           {onlineUsers.includes(chat) && <div className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 border-2 border-white rounded-full"></div>}
                       </div>
                       <div>
                           <div className="font-semibold text-gray-800">{chat}</div>
                           <div className="text-xs text-gray-500">{typingUsers[chat] ? <span className="text-blue-500 animate-pulse">schreibt...</span> : 'Klicken zum Chatten'}</div>
                       </div>
                   </div>
                   {unreadCounts[chat] > 0 && (
                       <div className="bg-red-500 text-white text-xs font-bold px-2 py-1 rounded-full shadow-sm animate-bounce">
                           {unreadCounts[chat]}
                       </div>
                   )}
                </div>
              ))}
            </div>
          </div>

          {/* Main Chat Area */}
          <div className="flex-1 flex flex-col bg-[#e5ddd5]">
            {currentChat ? (
                <>
                  {/* Header */}
                  <div className="bg-white p-3 px-6 shadow-sm flex justify-between items-center z-10">
                      <div className="flex items-center gap-3">
                          <div className="font-bold text-lg">{currentChat}</div>
                          {typingUsers[currentChat] && <span className="text-sm text-blue-500">schreibt...</span>}
                      </div>
                      <button onClick={() => setCurrentChat(null)} className="p-2 hover:bg-gray-100 rounded-full"><Icons.X /></button>
                  </div>

                  {/* Messages */}
                  <div className="flex-1 overflow-y-auto p-4 space-y-4" onClick={() => setSelectedMessage(null)}>
                      {(messages[currentChat] || []).map((msg, idx) => {
                          const isMe = msg.user === currentUser;
                          return (
                              <div key={msg.id} className={`flex w-full ${isMe ? 'justify-end' : 'justify-start'}`}>
                                  <div className={`relative max-w-[70%] md:max-w-[50%] min-w-[120px] message-bubble group`}>
                                      
                                      {/* Message Bubble */}
                                      <div className={`p-3 rounded-lg shadow-sm text-sm break-words relative
                                          ${isMe ? 'bg-[#d9fdd3] rounded-tr-none' : 'bg-white rounded-tl-none'}
                                          ${msg.deleted ? 'italic text-gray-500 border border-gray-200 bg-gray-50' : ''}
                                      `}
                                      onContextMenu={(e) => { e.preventDefault(); setSelectedMessage(msg.id); }}
                                      >
                                          {msg.text}
                                          <div className="text-[10px] text-gray-400 text-right mt-1 select-none">
                                              {new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                          </div>
                                      </div>

                                      {/* Reactions - JETZT UNTER DER NACHRICHT */}
                                      {!msg.deleted && msg.reactions && Object.keys(msg.reactions).length > 0 && (
                                          <div className={`reaction-bar ${isMe ? 'justify-end' : 'justify-start'}`}>
                                              {Object.entries(msg.reactions).map(([emoji, users]) => (
                                                  <span key={emoji} className="bg-white border border-gray-200 rounded-full px-1.5 py-0.5 text-xs shadow-sm flex items-center gap-1 cursor-pointer hover:bg-gray-50"
                                                        onClick={(e) => { e.stopPropagation(); addReaction(msg.id, emoji); }}>
                                                      {emoji} <span className="text-gray-500">{users.length}</span>
                                                  </span>
                                              ))}
                                          </div>
                                      )}

                                      {/* Context Menu / Popup */}
                                      {selectedMessage === msg.id && !msg.deleted && (
                                          <div className={`absolute z-50 bottom-full mb-2 bg-white rounded-lg shadow-xl p-2 menu-popup border border-gray-200
                                              ${isMe ? 'right-0 origin-bottom-right' : 'left-0 origin-bottom-left'}
                                          `} onClick={(e) => e.stopPropagation()}>
                                              {/* Emoji Row */}
                                              <div className="flex gap-1 mb-2 pb-2 border-b border-gray-100">
                                                  {reactionEmojis.map(e => (
                                                      <button key={e} onClick={() => addReaction(msg.id, e)} className="hover:scale-125 transition text-lg p-1">{e}</button>
                                                  ))}
                                              </div>
                                              {/* Actions */}
                                              <button onClick={() => deleteMessage(msg.id)} className="w-full text-left text-xs text-red-600 hover:bg-red-50 p-2 rounded flex items-center gap-2">
                                                  <Icons.Trash /> Nachricht l√∂schen
                                              </button>
                                          </div>
                                      )}
                                  </div>
                              </div>
                          );
                      })}
                      <div ref={messagesEndRef} />
                  </div>

                  {/* Input */}
                  <div className="p-3 bg-white border-t">
                      {showEmojiPicker && (
                          <div className="absolute bottom-20 left-4 bg-white shadow-xl border rounded-lg p-2 grid grid-cols-8 gap-2 z-50">
                              {emojis.map(e => <button key={e} onClick={() => setMessage(prev => prev + e)} className="text-xl p-1 hover:bg-gray-100 rounded">{e}</button>)}
                          </div>
                      )}
                      <div className="flex items-end gap-2 max-w-4xl mx-auto">
                          <button onClick={() => setShowEmojiPicker(!showEmojiPicker)} className="p-3 text-gray-500 hover:bg-gray-100 rounded-full"><Icons.Smile/></button>
                          <textarea 
                              value={message}
                              onChange={e => { setMessage(e.target.value); handleTyping(); }}
                              onKeyPress={e => e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), handleSendMessage())}
                              placeholder="Nachricht schreiben..."
                              disabled={isSending}
                              className="flex-1 bg-white border border-gray-300 rounded-2xl px-4 py-3 focus:outline-none focus:border-blue-500 resize-none max-h-32 text-sm"
                              rows={1}
                          />
                          <button 
                              onClick={handleSendMessage} 
                              disabled={!message.trim() || isSending}
                              className={`p-3 rounded-full shadow-md transition-all ${message.trim() && !isSending ? 'bg-blue-500 hover:bg-blue-600 text-white transform hover:scale-105' : 'bg-gray-200 text-gray-400 cursor-not-allowed'}`}
                          >
                              {isSending ? <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div> : <Icons.Send />}
                          </button>
                      </div>
                  </div>
                </>
            ) : (
                <div className="flex-1 flex items-center justify-center text-gray-400 flex-col">
                    <Icons.Lock />
                    <p className="mt-4 font-semibold">W√§hle einen Chat aus</p>
                    <p className="text-sm">Ende-zu-Ende verschl√ºsselt</p>
                </div>
            )}
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EncryptedChat />);
  </script>
</body>
</html>
