<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sicherer Chat V2</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom. production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    
    // WebSocket Setup
    let ws = null;
    
    const connectWebSocket = (onMessage) => {
      const protocol = window.location. protocol === 'https:' ? 'wss:' :  'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}`);
      
      ws.onopen = () => console.log('‚úÖ WebSocket verbunden');
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        onMessage(data);
      };
      ws.onerror = (error) => console.error('‚ùå WebSocket Fehler:', error);
      ws.onclose = () => {
        console.log('üîÑ WebSocket getrennt, Reconnect in 3s...');
        setTimeout(() => connectWebSocket(onMessage), 3000);
      };
      
      return ws;
    };
    
    // Storage API
    window.storage = {
      async get(key, shared = false) {
        try {
          const response = await fetch(`/api/storage/${key}? shared=${shared}`);
          if (!response.ok) throw new Error('Key not found');
          return await response.json();
        } catch (e) {
          throw e;
        }
      },
      async set(key, value, shared = false) {
        const response = await fetch(`/api/storage/${key}`, {
          method:  'POST',
          headers: { 'Content-Type':  'application/json' },
          body: JSON.stringify({ value, shared })
        });
        return await response.json();
      }
    };

    // Crypto Functions
    const deriveKeyFromPassword = async (password, salt) => {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']
      );
      return await crypto.subtle. deriveKey(
        { name: 'PBKDF2', salt:  salt, iterations: 300000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    };

    const generateUserKeypair = async () => {
      return await crypto.subtle.generateKey(
        { name: 'RSA-OAEP', modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: 'SHA-256' },
        true, ['encrypt', 'decrypt']
      );
    };

    const encryptPrivateKey = async (privateKey, password) => {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const key = await deriveKeyFromPassword(password, salt);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const exported = await crypto.subtle.exportKey('pkcs8', privateKey);
      const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, exported);
      const result = new Uint8Array(salt.length + iv.length + encrypted. byteLength);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(new Uint8Array(encrypted), salt.length + iv.length);
      return btoa(String.fromCharCode(...result));
    };

    const decryptPrivateKey = async (encryptedData, password) => {
      const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
      const salt = data.slice(0, 16);
      const iv = data. slice(16, 28);
      const encrypted = data.slice(28);
      const key = await deriveKeyFromPassword(password, salt);
      const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);
      return await crypto.subtle.importKey('pkcs8', decrypted, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['decrypt']);
    };

    const exportPublicKey = async (publicKey) => {
      const exported = await crypto.subtle.exportKey('spki', publicKey);
      return btoa(String. fromCharCode(...new Uint8Array(exported)));
    };

    const importPublicKey = async (keyData) => {
      const binary = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
      return await crypto.subtle. importKey('spki', binary, { name: 'RSA-OAEP', hash:  'SHA-256' }, true, ['encrypt']);
    };

    const encryptMessage = async (text, recipientPublicKey) => {
      const sessionKey = await crypto. subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = new TextEncoder();
      const encrypted = await crypto.subtle. encrypt({ name: 'AES-GCM', iv }, sessionKey, enc. encode(text));
      const exportedSessionKey = await crypto. subtle.exportKey('raw', sessionKey);
      const encryptedSessionKey = await crypto. subtle.encrypt({ name: 'RSA-OAEP' }, recipientPublicKey, exportedSessionKey);
      return {
        ciphertext: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
        iv: btoa(String.fromCharCode(... iv)),
        encryptedSessionKey:  btoa(String. fromCharCode(...new Uint8Array(encryptedSessionKey)))
      };
    };

    const decryptMessage = async (encrypted, privateKey) => {
      try {
        const encryptedSessionKeyData = Uint8Array.from(atob(encrypted. encryptedSessionKey), c => c.charCodeAt(0));
        const sessionKeyData = await crypto.subtle.decrypt({ name: 'RSA-OAEP' }, privateKey, encryptedSessionKeyData);
        const sessionKey = await crypto. subtle.importKey('raw', sessionKeyData, { name: 'AES-GCM', length:  256 }, false, ['decrypt']);
        const iv = Uint8Array.from(atob(encrypted.iv), c => c.charCodeAt(0));
        const ciphertext = Uint8Array. from(atob(encrypted.ciphertext), c => c.charCodeAt(0));
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, sessionKey, ciphertext);
        return new TextDecoder().decode(decrypted);
      } catch (e) {
        return '[Entschl√ºsselung fehlgeschlagen]';
      }
    };

    // Icons
    const LockIcon = () => (
      <svg className="w-12 h-12 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
      </svg>
    );

    const SendIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
      </svg>
    );

    const SearchIcon = () => (
      <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    );

    const XIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    );

    const SmileIcon = () => (
      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14. 828 14.828a4 4 0 01-5.656 0M9 10h. 01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    );

    const CheckIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
      </svg>
    );

    const SettingsIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10. 325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c. 94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
    );

    const TrashIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-. 867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
      </svg>
    );

    const EditIcon = () => (
      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
      </svg>
    );

    const EncryptedChat = () => {
      const [isLoggedIn, setIsLoggedIn] = useState(false);
      const [username, setUsername] = useState('');
      const [password, setPassword] = useState('');
      const [currentUser, setCurrentUser] = useState('');
      const [privateKey, setPrivateKey] = useState(null);
      const [currentChat, setCurrentChat] = useState(null);
      const [message, setMessage] = useState('');
      const [chats, setChats] = useState([]);
      const [messages, setMessages] = useState({});
      const [error, setError] = useState('');
      const [onlineUsers, setOnlineUsers] = useState([]);
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const [chatRequests, setChatRequests] = useState([]);
      const [pendingRequests, setPendingRequests] = useState([]);
      const [selectedMessage, setSelectedMessage] = useState(null);
      const [typingUsers, setTypingUsers] = useState({});
      const [showSettings, setShowSettings] = useState(false);
      const [unreadCounts, setUnreadCounts] = useState({});
      const [lastReadTimestamps, setLastReadTimestamps] = useState({});
      const [isSending, setIsSending] = useState(false);
      const [editingMessage, setEditingMessage] = useState(null);
      const [editText, setEditText] = useState('');
      const [isWindowFocused, setIsWindowFocused] = useState(true);
      const [longPressTimer, setLongPressTimer] = useState(null);
      const [showMessageMenu, setShowMessageMenu] = useState(null);
      
      const messagesEndRef = useRef(null);
      const wsRef = useRef(null);
      const currentChatRef = useRef(currentChat);
      const privateKeyRef = useRef(privateKey);
      const currentUserRef = useRef(currentUser);
      const loadingRef = useRef(false);
      const chatsRef = useRef(chats);

      const emojis = ['üòÄ', 'üòÇ', 'üòç', 'ü•∞', 'üòé', 'ü§î', 'üëç', 'üëè', 'üéâ', '‚ù§Ô∏è', 'üî•', '‚ú®', 'üíØ', 'üöÄ', '‚≠ê', 'üí™'];
      const reactionEmojis = ['‚ù§Ô∏è', 'üòÇ', 'üëç', 'üî•', 'üéâ', 'üòÆ'];

      // Keep refs updated
      useEffect(() => { currentChatRef.current = currentChat; }, [currentChat]);
      useEffect(() => { privateKeyRef. current = privateKey; }, [privateKey]);
      useEffect(() => { currentUserRef.current = currentUser; }, [currentUser]);
      useEffect(() => { chatsRef.current = chats; }, [chats]);

      // Window focus detection for real online status
      useEffect(() => {
        const handleFocus = () => {
          setIsWindowFocused(true);
          if (wsRef.current?. readyState === WebSocket.OPEN && currentUserRef.current) {
            wsRef.current.send(JSON.stringify({ type: 'user_online', username:  currentUserRef.current }));
          }
        };
        const handleBlur = () => {
          setIsWindowFocused(false);
          if (wsRef.current?.readyState === WebSocket.OPEN && currentUserRef.current) {
            wsRef.current.send(JSON.stringify({ type: 'user_away', username: currentUserRef.current }));
          }
        };
        window.addEventListener('focus', handleFocus);
        window.addEventListener('blur', handleBlur);
        return () => {
          window.removeEventListener('focus', handleFocus);
          window.removeEventListener('blur', handleBlur);
        };
      }, []);

      // Stable message loader
      const loadMessagesForChatStable = useCallback(async (chatUser) => {
        if (! chatUser || ! privateKeyRef.current || !currentUserRef. current) return;
        if (loadingRef. current) return;
        
        loadingRef.current = true;
        const chatId = [currentUserRef.current, chatUser].sort().join('_');
        
        try {
          const result = await window.storage.get(`messages_${chatId}`, true);
          const encryptedMessages = JSON.parse(result. value);
          
          const decryptedMessages = await Promise.all(
            encryptedMessages. map(async msg => {
              if (msg.deleted) return { ...msg, text: '[Nachricht gel√∂scht]' };
              
              let decryptedText = '';
              if (msg.user !== currentUserRef.current && msg.encryptedData) {
                decryptedText = await decryptMessage(msg.encryptedData, privateKeyRef.current);
              } else if (msg.user === currentUserRef.current && msg.encryptedForSender) {
                decryptedText = await decryptMessage(msg.encryptedForSender, privateKeyRef.current);
              } else if (msg.encryptedData) {
                decryptedText = await decryptMessage(msg.encryptedData, privateKeyRef. current);
              }
              return { ...msg, text: decryptedText };
            })
          );
          
          setMessages(prev => ({ ...prev, [chatUser]: decryptedMessages }));
        } catch (e) {
          setMessages(prev => ({ ... prev, [chatUser]: [] }));
        } finally {
          loadingRef.current = false;
        }
      }, []);

      // Check unread for all chats
      const checkAllUnreadMessages = useCallback(async () => {
        if (!currentUserRef.current || !privateKeyRef. current) return;
        const newUnreadCounts = {};
        
        for (const chatUser of chatsRef.current) {
          const chatId = [currentUserRef.current, chatUser].sort().join('_');
          try {
            const result = await window.storage.get(`messages_${chatId}`, true);
            const msgs = JSON.parse(result.value);
            const lastRead = lastReadTimestamps[chatUser] || 0;
            
            const unreadCount = msgs.filter(m => 
              m.user !== currentUserRef.current && 
              new Date(m.timestamp).getTime() > lastRead &&
              !m. deleted
            ).length;
            
            if (unreadCount > 0) newUnreadCounts[chatUser] = unreadCount;
          } catch (e) {}
        }
        
        setUnreadCounts(newUnreadCounts);
      }, [lastReadTimestamps]);

      // WebSocket setup
      useEffect(() => {
        if (!isLoggedIn || !currentUser) return;

        const handleMessage = (data) => {
          if (data.type === 'users_update') setOnlineUsers(data.users || []);
          if (data.type === 'new_message') {
            if (currentChatRef.current && privateKeyRef.current) {
              loadMessagesForChatStable(currentChatRef.current);
            }
            checkAllUnreadMessages();
          }
          if (data.type === 'chat_request') { loadChatRequests(); loadUserData(); }
          if (data.type === 'chat_accepted') { setTimeout(() => { loadUserData(); loadChatRequests(); }, 500); }
          if (data.type === 'chat_declined') { loadChatRequests(); loadUserData(); }
          if (data. type === 'typing' && data.user !== currentUserRef.current) {
            setTypingUsers(prev => ({ ...prev, [data.user]: true }));
            setTimeout(() => setTypingUsers(prev => { const n = { ...prev }; delete n[data.user]; return n; }), 3000);
          }
        };

        wsRef.current = connectWebSocket(handleMessage);
        ws = wsRef.current;
        setTimeout(() => {
          if (wsRef.current?. readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({ type: 'user_online', username:  currentUser }));
          }
        }, 500);

        return () => {
          if (wsRef.current) {
            try { wsRef.current. send(JSON.stringify({ type: 'user_offline', username:  currentUserRef.current })); } catch (e) {}
            wsRef. current. close();
          }
        };
      }, [isLoggedIn, currentUser, loadMessagesForChatStable, checkAllUnreadMessages]);

      // 1 second polling
      useEffect(() => {
        if (!isLoggedIn || !currentUser || !privateKey) return;
        const interval = setInterval(() => {
          if (currentChatRef.current) loadMessagesForChatStable(currentChatRef.current);
          checkAllUnreadMessages();
        }, 1000);
        return () => clearInterval(interval);
      }, [isLoggedIn, currentUser, privateKey, loadMessagesForChatStable, checkAllUnreadMessages]);

      // Mark chat as read
      useEffect(() => {
        if (currentChat) {
          setLastReadTimestamps(prev => ({ ... prev, [currentChat]: Date.now() }));
          setUnreadCounts(prev => { const n = { ...prev }; delete n[currentChat]; return n; });
          loadMessagesForChatStable(currentChat);
        }
      }, [currentChat, loadMessagesForChatStable]);

      useEffect(() => { messagesEndRef.current?. scrollIntoView({ behavior: 'smooth' }); }, [messages, currentChat]);

      useEffect(() => {
        if (isLoggedIn && currentUser) {
          loadUserData();
          loadChatRequests();
          const interval = setInterval(() => { loadChatRequests(); loadUserData(); }, 3000);
          return () => clearInterval(interval);
        }
      }, [isLoggedIn, currentUser]);

      const loadUserData = async () => {
        if (! currentUserRef.current) return;
        try {
          const result = await window.storage. get('chats_' + currentUserRef.current, true);
          setChats(JSON.parse(result. value));
        } catch (e) { setChats([]); }
      };

      const loadChatRequests = async () => {
        if (!currentUserRef.current) return;
        try {
          const result = await window.storage. get('requests_' + currentUserRef.current, true);
          setChatRequests(JSON. parse(result.value));
        } catch (e) { setChatRequests([]); }
        try {
          const result = await window.storage.get('pending_' + currentUserRef. current, true);
          setPendingRequests(JSON.parse(result.value));
        } catch (e) { setPendingRequests([]); }
      };

      const handleAuth = async () => {
        setError('');
        if (! username || !password) { setError('Bitte beide Felder ausf√ºllen'); return; }
        if (username.length < 3 || password.length < 6) { setError('Username min.  3, Passwort min. 6 Zeichen'); return; }

        try {
          let userData = {};
          try {
            const result = await window. storage.get('userdata_' + username, true);
            userData = JSON.parse(result.value);
          } catch (e) {
            const keypair = await generateUserKeypair();
            const encryptedPrivKey = await encryptPrivateKey(keypair.privateKey, password);
            const publicKey = await exportPublicKey(keypair.publicKey);
            userData = { encryptedPrivateKey:  encryptedPrivKey, publicKey };
            await window.storage. set('userdata_' + username, JSON.stringify(userData), true);
          }

          try {
            const privKey = await decryptPrivateKey(userData.encryptedPrivateKey, password);
            setPrivateKey(privKey);
            setCurrentUser(username);
            setIsLoggedIn(true);
            
            let allUsers = [];
            try { const r = await window.storage.get('all_users', true); allUsers = JSON. parse(r.value); } catch (e) {}
            if (! allUsers.includes(username)) {
              allUsers.push(username);
              await window.storage.set('all_users', JSON.stringify(allUsers), true);
            }
          } catch (e) { setError('Falsches Passwort'); }
        } catch (e) { setError('Fehler:  ' + e.message); }
      };

      const searchUsers = async (query) => {
        setSearchQuery(query);
        if (!query?. trim()) { setSearchResults([]); return; }
        try {
          let allUsers = [];
          try { const r = await window.storage. get('all_users', true); allUsers = JSON.parse(r.value); } catch (e) {}
          setSearchResults(allUsers.filter(u => u.toLowerCase().includes(query.toLowerCase()) && u !== currentUser));
        } catch (e) { setSearchResults([]); }
      };

      const sendChatRequest = async (targetUser) => {
        if (chats.includes(targetUser) || pendingRequests.includes(targetUser)) return;
        try {
          let theirRequests = [];
          try { const r = await window.storage. get('requests_' + targetUser, true); theirRequests = JSON.parse(r.value); } catch (e) {}
          if (! theirRequests. includes(currentUser)) {
            theirRequests. push(currentUser);
            await window. storage.set('requests_' + targetUser, JSON.stringify(theirRequests), true);
          }
          let myPending = [... pendingRequests];
          if (!myPending. includes(targetUser)) {
            myPending.push(targetUser);
            setPendingRequests(myPending);
            await window.storage.set('pending_' + currentUser, JSON.stringify(myPending), true);
          }
          if (ws?. readyState === WebSocket.OPEN) ws.send(JSON. stringify({ type: 'chat_request', to: targetUser }));
          setSearchQuery(''); setSearchResults([]);
        } catch (e) { setError('Fehler beim Senden der Anfrage'); }
      };

      const acceptChatRequest = async (requester) => {
        try {
          let newChats = [... chats];
          if (!newChats. includes(requester)) {
            newChats.push(requester);
            setChats(newChats);
            await window.storage.set('chats_' + currentUser, JSON.stringify(newChats), true);
          }
          let theirChats = [];
          try { const r = await window.storage. get('chats_' + requester, true); theirChats = JSON.parse(r.value); } catch (e) {}
          if (! theirChats. includes(currentUser)) {
            theirChats. push(currentUser);
            await window. storage.set('chats_' + requester, JSON.stringify(theirChats), true);
          }
          const newRequests = chatRequests.filter(r => r !== requester);
          setChatRequests(newRequests);
          await window.storage.set('requests_' + currentUser, JSON. stringify(newRequests), true);
          try {
            const r = await window.storage.get('pending_' + requester, true);
            let theirPending = JSON.parse(r. value).filter(p => p !== currentUser);
            await window.storage.set('pending_' + requester, JSON. stringify(theirPending), true);
          } catch (e) {}
          setCurrentChat(requester);
          if (wsRef.current?. readyState === WebSocket.OPEN) {
            wsRef. current.send(JSON.stringify({ type: 'chat_accepted', from: currentUser, to: requester }));
          }
        } catch (e) { setError('Fehler beim Akzeptieren:  ' + e.message); }
      };

      const declineChatRequest = async (requester) => {
        try {
          const newRequests = chatRequests.filter(r => r !== requester);
          setChatRequests(newRequests);
          await window.storage.set('requests_' + currentUser, JSON.stringify(newRequests), true);
          try {
            const r = await window.storage.get('pending_' + requester, true);
            let theirPending = JSON.parse(r.value).filter(p => p !== currentUser);
            await window.storage.set('pending_' + requester, JSON. stringify(theirPending), true);
          } catch (e) {}
          if (wsRef.current?.readyState === WebSocket. OPEN) {
            wsRef.current.send(JSON. stringify({ type: 'chat_declined', from: currentUser, to: requester }));
          }
        } catch (e) { setError('Fehler beim Ablehnen: ' + e.message); }
      };

      // Prevent double send
      const handleSendMessage = async () => {
        if (! message.trim() || !currentChat || !privateKey || isSending) return;
        setIsSending(true);
        const messageToSend = message;
        setMessage('');

        try {
          const myData = await window.storage.get('userdata_' + currentUser, true);
          const myPublicKey = await importPublicKey(JSON.parse(myData.value).publicKey);
          const recipientData = await window.storage.get('userdata_' + currentChat, true);
          const recipientPublicKey = await importPublicKey(JSON.parse(recipientData.value).publicKey);

          const encryptedForRecipient = await encryptMessage(messageToSend, recipientPublicKey);
          const encryptedForMe = await encryptMessage(messageToSend, myPublicKey);

          const newMessage = {
            id: Date.now(),
            user: currentUser,
            encryptedData: encryptedForRecipient,
            encryptedForSender: encryptedForMe,
            reactions: {},
            timestamp: new Date().toISOString()
          };

          const chatId = [currentUser, currentChat].sort().join('_');
          let existingMessages = [];
          try { const r = await window. storage.get(`messages_${chatId}`, true); existingMessages = JSON. parse(r.value); } catch (e) {}
          existingMessages.push(newMessage);
          await window.storage. set(`messages_${chatId}`, JSON.stringify(existingMessages), true);
          
          if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef. current.send(JSON.stringify({ type: 'new_message', chat: chatId }));
          }
          await loadMessagesForChatStable(currentChat);
          setShowEmojiPicker(false);
        } catch (e) {
          setError('Fehler beim Senden:  ' + e.message);
          setMessage(messageToSend);
        } finally {
          setIsSending(false);
        }
      };

      // Delete message
      const deleteMessage = async (messageId) => {
        if (!currentChat) return;
        try {
          const chatId = [currentUser, currentChat].sort().join('_');
          const result = await window.storage.get(`messages_${chatId}`, true);
          let allMessages = JSON.parse(result. value);
          const msgIndex = allMessages. findIndex(m => m.id === messageId);
          if (msgIndex !== -1 && allMessages[msgIndex].user === currentUser) {
            allMessages[msgIndex]. deleted = true;
            allMessages[msgIndex].encryptedData = null;
            allMessages[msgIndex]. encryptedForSender = null;
            await window.storage.set(`messages_${chatId}`, JSON.stringify(allMessages), true);
            await loadMessagesForChatStable(currentChat);
            if (wsRef.current?.readyState === WebSocket.OPEN) {
              wsRef.current.send(JSON.stringify({ type: 'new_message', chat:  chatId }));
            }
          }
        } catch (e) { console.error('Fehler beim L√∂schen:', e); }
        setShowMessageMenu(null);
        setSelectedMessage(null);
      };

      // Edit message
      const startEditMessage = (msg) => {
        if (msg.user !== currentUser || msg.deleted) return;
        setEditingMessage(msg. id);
        setEditText(msg. text);
        setShowMessageMenu(null);
        setSelectedMessage(null);
      };

      const saveEditMessage = async () => {
        if (!editingMessage || !editText.trim() || !currentChat) return;
        try {
          const myData = await window. storage.get('userdata_' + currentUser, true);
          const myPublicKey = await importPublicKey(JSON. parse(myData. value).publicKey);
          const recipientData = await window. storage.get('userdata_' + currentChat, true);
          const recipientPublicKey = await importPublicKey(JSON.parse(recipientData.value).publicKey);

          const encryptedForRecipient = await encryptMessage(editText, recipientPublicKey);
          const encryptedForMe = await encryptMessage(editText, myPublicKey);

          const chatId = [currentUser, currentChat].sort().join('_');
          const result = await window.storage.get(`messages_${chatId}`, true);
          let allMessages = JSON. parse(result.value);
          const msgIndex = allMessages. findIndex(m => m.id === editingMessage);
          if (msgIndex !== -1 && allMessages[msgIndex].user === currentUser) {
            allMessages[msgIndex].encryptedData = encryptedForRecipient;
            allMessages[msgIndex].encryptedForSender = encryptedForMe;
            allMessages[msgIndex].edited = true;
            await window.storage. set(`messages_${chatId}`, JSON.stringify(allMessages), true);
            await loadMessagesForChatStable(currentChat);
            if (wsRef. current?.readyState === WebSocket. OPEN) {
              wsRef.current. send(JSON.stringify({ type: 'new_message', chat: chatId }));
            }
          }
        } catch (e) { console.error('Fehler beim Bearbeiten:', e); }
        setEditingMessage(null);
        setEditText('');
      };

      const cancelEdit = () => {
        setEditingMessage(null);
        setEditText('');
      };

      const addReaction = async (messageId, emoji) => {
        if (! currentChat) return;
        try {
          const chatId = [currentUser, currentChat].sort().join('_');
          const result = await window.storage.get(`messages_${chatId}`, true);
          let allMessages = JSON.parse(result.value);
          const msgIndex = allMessages.findIndex(m => m.id === messageId);
          if (msgIndex !== -1) {
            if (!allMessages[msgIndex].reactions) allMessages[msgIndex]. reactions = {};
            if (!allMessages[msgIndex].reactions[emoji]) allMessages[msgIndex].reactions[emoji] = [];
            const userIndex = allMessages[msgIndex].reactions[emoji].indexOf(currentUser);
            if (userIndex === -1) {
              allMessages[msgIndex]. reactions[emoji].push(currentUser);
            } else {
              allMessages[msgIndex].reactions[emoji]. splice(userIndex, 1);
              if (allMessages[msgIndex].reactions[emoji].length === 0) delete allMessages[msgIndex].reactions[emoji];
            }
            await window. storage.set(`messages_${chatId}`, JSON.stringify(allMessages), true);
            await loadMessagesForChatStable(currentChat);
          }
        } catch (e) { console.error('Fehler beim Reagieren:', e); }
        setSelectedMessage(null);
        setShowMessageMenu(null);
      };

      // Long press handlers
      const handleTouchStart = (msgId) => {
        const timer = setTimeout(() => setShowMessageMenu(msgId), 500);
        setLongPressTimer(timer);
      };
      const handleTouchEnd = () => { if (longPressTimer) { clearTimeout(longPressTimer); setLongPressTimer(null); } };

      const handleLogout = () => {
        if (wsRef.current?. readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ type: 'user_offline', username: currentUser }));
        }
        setIsLoggedIn(false); setCurrentUser(''); setCurrentChat(null); setMessages({});
        setChats([]); setPassword(''); setPrivateKey(null); setShowSettings(false);
        setUnreadCounts({}); setLastReadTimestamps({});
      };

      const handleKeyPress = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e. preventDefault();
          if (editingMessage) saveEditMessage();
          else if (currentChat) handleSendMessage();
          else handleAuth();
        }
      };

      const handleTyping = () => {
        if (wsRef.current?.readyState === WebSocket.OPEN && currentChat) {
          const chatId = [currentUser, currentChat].sort().join('_');
          wsRef. current.send(JSON.stringify({ type: 'typing', chat: chatId, user: currentUser }));
        }
      };

      const deleteAccount = async () => {
        if (! confirm('M√∂chtest du deinen Account wirklich l√∂schen?')) return;
        try {
          await window.storage.set('userdata_' + currentUser, JSON.stringify({}), true);
          await window. storage.set('chats_' + currentUser, JSON.stringify([]), true);
          await window.storage. set('requests_' + currentUser, JSON.stringify([]), true);
          await window.storage. set('pending_' + currentUser, JSON.stringify([]), true);
          handleLogout();
          alert('Account wurde gel√∂scht');
        } catch (e) { setError('Fehler beim L√∂schen des Accounts: ' + e. message); }
      };

      const addEmoji = (emoji) => {
        if (editingMessage) setEditText(editText + emoji);
        else setMessage(message + emoji);
      };

      const getLastMessage = (chatUser) => {
        const msgs = messages[chatUser] || [];
        if (msgs.length === 0) return 'Noch keine Nachrichten';
        const last = msgs[msgs. length - 1];
        if (last.deleted) return '[Nachricht gel√∂scht]';
        return last.text. substring(0, 30) + (last.text.length > 30 ?  '...' : '');
      };

      // Login Screen
      if (! isLoggedIn) {
        return (
          <div className="h-screen bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 w-full max-w-md">
              <div className="flex items-center justify-center mb-6"><LockIcon /></div>
              <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">Sicherer Chat V2</h1>
              <p className="text-center text-gray-600 mb-2">Ende-zu-Ende verschl√ºsselt</p>
              <p className="text-center text-xs text-gray-500 mb-8">RSA-2048 + AES-256-GCM</p>
              
              <div className="space-y-4">
                <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} onKeyPress={handleKeyPress}
                  className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                  placeholder="Benutzername (min.  3 Zeichen)" />
                <input type="password" value={password} onChange={(e) => setPassword(e. target.value)} onKeyPress={handleKeyPress}
                  className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                  placeholder="Passwort (min. 6 Zeichen)" />
                {error && <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl text-sm">{error}</div>}
                <button onClick={handleAuth} className="w-full bg-blue-500 text-white py-3 rounded-xl font-semibold hover:bg-blue-600 transition shadow-lg">
                  Anmelden / Registrieren
                </button>
              </div>
              <p className="text-xs text-gray-500 text-center mt-6">Server kann Nachrichten nicht lesen</p>
            </div>
          </div>
        );
      }

      // Main Chat UI
      return (
        <div className="h-screen flex bg-gray-100">
          {/* Sidebar */}
          <div className="w-80 bg-white border-r border-gray-200 flex flex-col">
            <div className="p-4 border-b border-gray-200 bg-white">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold text-gray-800">Nachrichten</h2>
                <div className="flex gap-2">
                  <button onClick={() => setShowSettings(! showSettings)} className="p-2 hover:bg-gray-100 rounded-lg transition" title="Einstellungen">
                    <SettingsIcon />
                  </button>
                  <button onClick={handleLogout} className="px-3 py-1 bg-red-500 text-white text-sm rounded-lg hover:bg-red-600 transition">Abmelden</button>
                </div>
              </div>

              {showSettings && (
                <div className="mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                  <h3 className="font-semibold text-gray-800 mb-3">Einstellungen</h3>
                  <div className="space-y-2">
                    <div className="text-sm text-gray-600">
                      <p><strong>Benutzername:</strong> {currentUser}</p>
                      <p><strong>Status:</strong> <span className="text-green-600">‚óè Online</span></p>
                    </div>
                    <button onClick={deleteAccount} className="w-full flex items-center justify-center gap-2 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition">
                      <TrashIcon /> Account l√∂schen
                    </button>
                  </div>
                </div>
              )}
              
              <div className="relative">
                <input type="text" value={searchQuery} onChange={(e) => searchUsers(e.target. value)} placeholder="Benutzer suchen..."
                  className="w-full pl-10 pr-4 py-2 bg-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500" />
                <div className="absolute left-3 top-2.5"><SearchIcon /></div>
              </div>
              
              {searchQuery?. trim() && (
                <div className="mt-2 bg-white border border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto z-50 absolute w-72">
                  {searchResults.length === 0 ? (
                    <div className="px-4 py-3 text-center text-gray-500 text-sm">Keine Benutzer gefunden</div>
                  ) : (
                    searchResults.map(user => {
                      const isPending = pendingRequests. includes(user);
                      const hasRequest = chatRequests.includes(user);
                      const isConnected = chats.includes(user);
                      return (
                        <button key={user} onClick={() => { if (!isPending && !hasRequest && ! isConnected) sendChatRequest(user); }}
                          disabled={isPending || hasRequest || isConnected}
                          className={`w-full text-left px-4 py-3 flex items-center justify-between border-b border-gray-100 last:border-0 ${
                            isPending || hasRequest || isConnected ? 'bg-gray-50 cursor-not-allowed' : 'hover:bg-blue-50 cursor-pointer'
                          }`}>
                          <div className="flex items-center gap-3">
                            <div className="w-8 h-8 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-xs">
                              {user[0]. toUpperCase()}
                            </div>
                            <div>
                              <span className="font-medium block">{user}</span>
                              {isPending && <span className="text-xs text-orange-500">‚è≥ Anfrage gesendet</span>}
                              {hasRequest && <span className="text-xs text-blue-500">üì© Anfrage erhalten</span>}
                              {isConnected && <span className="text-xs text-green-500">‚úì Verbunden</span>}
                            </div>
                          </div>
                        </button>
                      );
                    })
                  )}
                </div>
              )}
            </div>

            {chatRequests.length > 0 && (
              <div className="bg-blue-50 border-b border-blue-200 p-3">
                <p className="text-sm font-semibold text-blue-900 mb-2">Chat-Anfragen ({chatRequests.length})</p>
                {chatRequests.map(requester => (
                  <div key={requester} className="bg-white rounded-lg p-3 mb-2 flex items-center justify-between shadow-sm">
                    <div className="flex items-center gap-2">
                      <div className="w-8 h-8 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                        {requester[0]. toUpperCase()}
                      </div>
                      <span className="font-medium text-sm">{requester}</span>
                    </div>
                    <div className="flex gap-1">
                      <button onClick={() => acceptChatRequest(requester)} className="p-1.5 bg-green-500 text-white rounded hover:bg-green-600 transition"><CheckIcon /></button>
                      <button onClick={() => declineChatRequest(requester)} className="p-1.5 bg-red-500 text-white rounded hover:bg-red-600 transition"><XIcon /></button>
                    </div>
                  </div>
                ))}
              </div>
            )}

            <div className="flex-1 overflow-y-auto">
              {chats.length === 0 ? (
                <div className="p-8 text-center text-gray-500">
                  <p className="mb-2">Noch keine Chats</p>
                  <p className="text-sm">Suche oben nach Benutzern</p>
                </div>
              ) : (
                chats.map(chatUser => (
                  <button key={chatUser} onClick={() => setCurrentChat(chatUser)}
                    className={`w-full text-left px-4 py-4 hover:bg-gray-50 border-b border-gray-100 transition ${
                      currentChat === chatUser ?  'bg-blue-50 border-l-4 border-l-blue-500' : ''
                    }`}>
                    <div className="flex items-center gap-3">
                      <div className="relative">
                        <div className="w-12 h-12 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-lg">
                          {chatUser[0]. toUpperCase()}
                        </div>
                        {onlineUsers.includes(chatUser) && (
                          <span className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-white"></span>
                        )}
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center justify-between">
                          <p className="font-semibold text-gray-900">{chatUser}</p>
                          {unreadCounts[chatUser] > 0 && (
                            <span className="bg-blue-500 text-white text-xs font-bold px-2 py-1 rounded-full min-w-[20px] text-center">
                              {unreadCounts[chatUser]}
                            </span>
                          )}
                        </div>
                        <p className="text-sm text-gray-500 truncate">{getLastMessage(chatUser)}</p>
                      </div>
                    </div>
                  </button>
                ))
              )}
            </div>
          </div>

          {/* Chat Area */}
          <div className="flex-1 flex flex-col">
            {currentChat ?  (
              <>
                <div className="bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between shadow-sm z-10">
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                      {currentChat[0].toUpperCase()}
                    </div>
                    <div>
                      <p className="font-semibold text-gray-900">{currentChat}</p>
                      <p className="text-sm text-gray-500">
                        {typingUsers[currentChat] ? 'schreibt...' :  onlineUsers.includes(currentChat) ? '‚óè Online' : '‚óã Offline'}
                      </p>
                    </div>
                  </div>
                  <button onClick={() => setCurrentChat(null)} className="p-2 hover: bg-gray-100 rounded-full transition"><XIcon /></button>
                </div>

                <div className="flex-1 overflow-y-auto p-6 bg-gray-50" onClick={() => { setShowMessageMenu(null); setSelectedMessage(null); }}>
                  {(messages[currentChat] || []).length === 0 ?  (
                    <div className="text-center text-gray-500 mt-20">
                      <p>Noch keine Nachrichten</p>
                      <p className="text-sm mt-2">Schreibe die erste Nachricht!  üëã</p>
                    </div>
                  ) : (
                    (messages[currentChat] || []).map(msg => (
                      <div key={msg.id} className={`flex flex-col mb-4 ${msg.user === currentUser ? 'items-end' : 'items-start'}`}>
                        <div className="relative group"
                          onTouchStart={() => handleTouchStart(msg.id)}
                          onTouchEnd={handleTouchEnd}
                          onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); setShowMessageMenu(msg.id); }}>
                          
                          <div className={`max-w-xs lg:max-w-md px-4 py-2 rounded-2xl cursor-pointer ${
                            msg. user === currentUser
                              ? 'bg-blue-500 text-white rounded-br-none shadow-md'
                              : 'bg-white text-gray-800 rounded-bl-none shadow-md'
                          } ${msg.deleted ? 'opacity-50 italic' : ''}`}
                            onClick={(e) => { e.stopPropagation(); if (! msg.deleted) setSelectedMessage(msg. id === selectedMessage ?  null : msg.id); }}>
                            
                            {msg.deleted ?  (
                              <p className="break-words whitespace-pre-wrap text-sm italic">üóëÔ∏è Nachricht gel√∂scht</p>
                            ) : msg.text === '[Entschl√ºsselung fehlgeschlagen]' ? (
                              <p className="break-words whitespace-pre-wrap text-red-400 italic text-sm">üîí Warte auf Freigabe... </p>
                            ) : (
                              <p className="break-words whitespace-pre-wrap">{msg.text}</p>
                            )}
                            
                            <div className="flex items-center gap-1 justify-end mt-1">
                              {msg.edited && ! msg.deleted && (
                                <span className={`text-xs ${msg.user === currentUser ? 'text-blue-200' : 'text-gray-400'}`}>(bearbeitet)</span>
                              )}
                              <span className={`text-xs ${msg.user === currentUser ? 'text-blue-100' : 'text-gray-400'}`}>
                                {new Date(msg.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}
                              </span>
                            </div>
                          </div>

                          {/* Reactions below message */}
                          {msg.reactions && Object.keys(msg. reactions).length > 0 && (
                            <div className={`flex gap-1 mt-1 flex-wrap ${msg. user === currentUser ? 'justify-end' : 'justify-start'}`}>
                              {Object.entries(msg. reactions).map(([emoji, users]) => (
                                users.length > 0 && (
                                  <span key={emoji} onClick={() => addReaction(msg.id, emoji)}
                                    className="bg-white rounded-full px-2 py-0.5 text-sm flex items-center gap-1 shadow-sm border border-gray-200 cursor-pointer hover:bg-gray-50">
                                    {emoji} <span className="text-xs text-gray-600">{users.length}</span>
                                  </span>
                                )
                              ))}
                            </div>
                          )}

                          {/* Message menu */}
                          {showMessageMenu === msg.id && ! msg.deleted && (
                            <div className={`absolute z-30 bg-white rounded-lg shadow-xl border border-gray-200 py-1 min-w-[160px] ${
                              msg.user === currentUser ? 'right-0' : 'left-0'
                            }`} style={{ bottom: '100%', marginBottom: '8px' }} onClick={(e) => e.stopPropagation()}>
                              
                              <div className="flex gap-1 px-2 py-2 border-b border-gray-100">
                                {reactionEmojis. map(emoji => (
                                  <button key={emoji} onClick={() => addReaction(msg.id, emoji)}
                                    className="text-lg hover:scale-125 transition-transform">{emoji}</button>
                                ))}
                              </div>
                              
                              {msg.user === currentUser && (
                                <>
                                  <button onClick={() => startEditMessage(msg)}
                                    className="w-full text-left px-3 py-2 hover:bg-gray-100 flex items-center gap-2 text-sm">
                                    <EditIcon /> Bearbeiten
                                  </button>
                                  <button onClick={() => deleteMessage(msg. id)}
                                    className="w-full text-left px-3 py-2 hover:bg-red-50 text-red-600 flex items-center gap-2 text-sm">
                                    <TrashIcon /> L√∂schen
                                  </button>
                                </>
                              )}
                              
                              <button onClick={() => setShowMessageMenu(null)}
                                className="w-full text-left px-3 py-2 hover:bg-gray-100 text-gray-500 text-sm">
                                Abbrechen
                              </button>
                            </div>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                  <div ref={messagesEndRef} />
                </div>

                {/* Input Area */}
                <div className="bg-white border-t border-gray-200 p-4 shadow-lg">
                  {editingMessage && (
                    <div className="mb-3 p-3 bg-blue-50 rounded-lg border border-blue-200 flex items-center justify-between">
                      <span className="text-sm text-blue-700">Nachricht bearbeiten</span>
                      <button onClick={cancelEdit} className="text-blue-500 hover: text-blue-700"><XIcon /></button>
                    </div>
                  )}
                  
                  {showEmojiPicker && (
                    <div className="mb-3 p-3 bg-gray-50 rounded-2xl flex flex-wrap gap-2 border border-gray-200">
                      {emojis.map((emoji, idx) => (
                        <button key={idx} onClick={() => addEmoji(emoji)} className="text-2xl hover:scale-125 transition-transform">{emoji}</button>
                      ))}
                    </div>
                  )}
                  
                  <div className="flex items-end gap-2">
                    <button onClick={() => setShowEmojiPicker(! showEmojiPicker)}
                      className="p-3 text-gray-500 hover:text-gray-700 transition hover:bg-gray-100 rounded-full">
                      <SmileIcon />
                    </button>
                    <textarea
                      value={editingMessage ?  editText : message}
                      onChange={(e) => {
                        if (editingMessage) setEditText(e. target.value);
                        else { setMessage(e. target.value); handleTyping(); }
                      }}
                      onKeyPress={handleKeyPress}
                      placeholder={editingMessage ? "Nachricht bearbeiten..." : "Nachricht schreiben..."}
                      rows="1"
                      className="flex-1 px-4 py-3 border border-gray-300 rounded-2xl focus:border-blue-500 focus:outline-none resize-none focus:ring-1 focus:ring-blue-500 bg-gray-50"
                      style={{ maxHeight: '100px' }}
                    />
                    <button
                      onClick={editingMessage ? saveEditMessage : handleSendMessage}
                      disabled={editingMessage ?  ! editText.trim() : (! message.trim() || isSending)}
                      className={`p-3 rounded-full transition shadow-md flex items-center justify-center ${
                        (editingMessage ?  editText.trim() : (message.trim() && !isSending))
                          ? 'bg-blue-500 text-white hover:bg-blue-600'
                          : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                      }`}>
                      {isSending ? (
                        <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                      ) : (
                        <SendIcon />
                      )}
                    </button>
                  </div>
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center bg-gray-50">
                <div className="text-center text-gray-500">
                  <div className="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mx-auto mb-4"> 
                    <svg className="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h. 01M21 12c0 4.418-4.03 8-9 8a9. 863 9.863 0 01-4.255-. 949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                  </div>
                  <h3 className="text-xl font-semibold mb-2 text-gray-700">Willkommen beim Sicheren Chat</h3>
                  <p className="text-sm max-w-xs mx-auto">W√§hle einen Chat aus der Leiste oder suche nach neuen Kontakten. </p>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.render(<EncryptedChat />, document.getElementById('root'));
  </script>
</body>
</html>
