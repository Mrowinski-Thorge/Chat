<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sicherer Chat</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // WebSocket Setup
    let ws = null;
    
    const connectWebSocket = (onMessage) => {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}`);
      
      ws.onopen = () => console.log('âœ… WebSocket verbunden');
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        onMessage(data);
      };
      ws.onerror = (error) => console.error('âŒ WebSocket Fehler:', error);
      ws.onclose = () => {
        console.log('ðŸ”„ WebSocket getrennt, Reconnect in 3s...');
        setTimeout(() => connectWebSocket(onMessage), 3000);
      };
      
      return ws;
    };
    
    // Storage API
    window.storage = {
      async get(key, shared = false) {
        try {
          const response = await fetch(`/api/storage/${key}?shared=${shared}`);
          if (!response.ok) throw new Error('Key not found');
          return await response.json();
        } catch (e) {
          throw e;
        }
      },
      async set(key, value, shared = false) {
        const response = await fetch(`/api/storage/${key}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ value, shared })
        });
        return await response.json();
      }
    };

    // Icons
    const LockIcon = () => (
      <svg className="w-12 h-12 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
      </svg>
    );

    const SendIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
      </svg>
    );

    const SearchIcon = () => (
      <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    );

    const XIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    );

    const SmileIcon = () => (
      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    );

    const PaperclipIcon = () => (
      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
      </svg>
    );

    const EncryptedChat = () => {
      const [isLoggedIn, setIsLoggedIn] = useState(false);
      const [username, setUsername] = useState('');
      const [password, setPassword] = useState('');
      const [currentUser, setCurrentUser] = useState('');
      const [currentChat, setCurrentChat] = useState(null);
      const [message, setMessage] = useState('');
      const [chats, setChats] = useState([]);
      const [messages, setMessages] = useState({});
      const [error, setError] = useState('');
      const [onlineUsers, setOnlineUsers] = useState([]);
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const messagesEndRef = useRef(null);

      const emojis = ['ðŸ˜€', 'ðŸ˜‚', 'ðŸ˜', 'ðŸ¥°', 'ðŸ˜Ž', 'ðŸ¤”', 'ðŸ‘', 'ðŸ‘', 'ðŸŽ‰', 'â¤ï¸', 'ðŸ”¥', 'âœ¨', 'ðŸ’¯', 'ðŸš€', 'â­', 'ðŸ’ª', 'ðŸŽˆ', 'ðŸŒŸ', 'ðŸ’', 'ðŸŒˆ'];

      // Einfache aber sichere VerschlÃ¼sselung
      const simpleEncrypt = (text, key) => {
        const combined = text + '|||' + key;
        return btoa(unescape(encodeURIComponent(combined)));
      };

      const simpleDecrypt = (encrypted, key) => {
        try {
          const decoded = decodeURIComponent(escape(atob(encrypted)));
          const parts = decoded.split('|||');
          if (parts.length === 2 && parts[1] === key) {
            return parts[0];
          }
          return '[Falsches Passwort]';
        } catch (e) {
          return '[EntschlÃ¼sselung fehlgeschlagen]';
        }
      };

      const hashPassword = (pass) => {
        let hash = 0;
        const str = pass + 'salt_2025';
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return hash.toString(36);
      };

      useEffect(() => {
        loadChats();
        
        const wsConnection = connectWebSocket((data) => {
          if (data.type === 'users_update') {
            setOnlineUsers(data.users);
          }
          if (data.type === 'new_message') {
            loadMessagesForChat(currentChat);
          }
        });

        return () => {
          if (wsConnection) wsConnection.close();
        };
      }, []);

      useEffect(() => {
        if (isLoggedIn && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'user_online', username: currentUser }));
          return () => {
            ws.send(JSON.stringify({ type: 'user_offline', username: currentUser }));
          };
        }
      }, [isLoggedIn, currentUser]);

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages, currentChat]);

      const loadChats = async () => {
        try {
          const result = await window.storage.get('chats_' + currentUser, true);
          setChats(JSON.parse(result.value));
        } catch (e) {
          setChats([]);
        }
      };

      const loadMessagesForChat = async (chatUser) => {
        if (!chatUser) return;
        
        const chatId = [currentUser, chatUser].sort().join('_');
        try {
          const result = await window.storage.get(`messages_${chatId}`, true);
          const encryptedMessages = JSON.parse(result.value);
          const decryptedMessages = encryptedMessages.map(msg => ({
            ...msg,
            text: simpleDecrypt(msg.text, password)
          }));
          setMessages(prev => ({ ...prev, [chatUser]: decryptedMessages }));
        } catch (e) {
          setMessages(prev => ({ ...prev, [chatUser]: [] }));
        }
      };

      const handleAuth = async () => {
        setError('');
        if (!username || !password) {
          setError('Bitte beide Felder ausfÃ¼llen');
          return;
        }

        if (username.length < 3 || password.length < 6) {
          setError('Username min. 3, Passwort min. 6 Zeichen');
          return;
        }

        try {
          let users = {};
          try {
            const result = await window.storage.get('users', true);
            users = JSON.parse(result.value);
          } catch (e) {
            users = {};
          }

          const hashedPass = hashPassword(password);

          if (users[username]) {
            if (users[username] === hashedPass) {
              setCurrentUser(username);
              setIsLoggedIn(true);
              await loadChats();
            } else {
              setError('Falsches Passwort');
            }
          } else {
            users[username] = hashedPass;
            await window.storage.set('users', JSON.stringify(users), true);
            setCurrentUser(username);
            setIsLoggedIn(true);
          }
        } catch (e) {
          setError('Fehler: ' + e.message);
        }
      };

      const searchUsers = async (query) => {
        if (!query || query.length < 2) {
          setSearchResults([]);
          return;
        }
        try {
          const response = await fetch(`/api/users/search?q=${query}`);
          const users = await response.json();
          setSearchResults(users.filter(u => u !== currentUser));
        } catch (e) {
          setSearchResults([]);
        }
      };

      const startChat = async (targetUser) => {
        if (!chats.includes(targetUser)) {
          const newChats = [...chats, targetUser];
          setChats(newChats);
          await window.storage.set('chats_' + currentUser, JSON.stringify(newChats), true);
        }
        setCurrentChat(targetUser);
        await loadMessagesForChat(targetUser);
        setSearchQuery('');
        setSearchResults([]);
      };

      const handleSendMessage = async () => {
        if (!message.trim() || !currentChat) return;

        try {
          const encryptedText = simpleEncrypt(message, password);
          const newMessage = {
            id: Date.now(),
            user: currentUser,
            text: encryptedText,
            timestamp: new Date().toISOString()
          };

          const chatId = [currentUser, currentChat].sort().join('_');
          let existingMessages = [];
          
          try {
            const result = await window.storage.get(`messages_${chatId}`, true);
            existingMessages = JSON.parse(result.value);
          } catch (e) {
            existingMessages = [];
          }
          
          existingMessages.push(newMessage);
          await window.storage.set(`messages_${chatId}`, JSON.stringify(existingMessages), true);
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'new_message', chat: chatId }));
          }
          
          await loadMessagesForChat(currentChat);
          setMessage('');
          setShowEmojiPicker(false);
        } catch (e) {
          setError('Fehler beim Senden: ' + e.message);
        }
      };

      const handleLogout = () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'user_offline', username: currentUser }));
        }
        setIsLoggedIn(false);
        setCurrentUser('');
        setCurrentChat(null);
        setMessages({});
        setChats([]);
        setPassword('');
      };

      const handleKeyPress = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (currentChat) {
            handleSendMessage();
          } else {
            handleAuth();
          }
        }
      };

      const addEmoji = (emoji) => {
        setMessage(message + emoji);
      };

      const getLastMessage = (chatUser) => {
        const msgs = messages[chatUser] || [];
        if (msgs.length === 0) return 'Noch keine Nachrichten';
        const last = msgs[msgs.length - 1];
        return last.text.substring(0, 30) + (last.text.length > 30 ? '...' : '');
      };

      if (!isLoggedIn) {
        return (
          <div className="h-screen bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 w-full max-w-md">
              <div className="flex items-center justify-center mb-6">
                <LockIcon />
              </div>
              <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">Sicherer Chat</h1>
              <p className="text-center text-gray-600 mb-8">Ende-zu-Ende verschlÃ¼sselt</p>
              
              <div className="space-y-4">
                <input
                  type="text"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                  placeholder="Benutzername (min. 3 Zeichen)"
                />
                
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                  placeholder="Passwort (min. 6 Zeichen)"
                />

                {error && (
                  <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl">
                    {error}
                  </div>
                )}

                <button
                  onClick={handleAuth}
                  className="w-full bg-blue-500 text-white py-3 rounded-xl font-semibold hover:bg-blue-600 transition shadow-lg"
                >
                  Anmelden / Registrieren
                </button>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="h-screen flex bg-gray-100">
          {/* Sidebar - Chatliste */}
          <div className="w-80 bg-white border-r border-gray-200 flex flex-col">
            <div className="p-4 border-b border-gray-200 bg-white">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold text-gray-800">Nachrichten</h2>
                <button
                  onClick={handleLogout}
                  className="px-3 py-1 bg-red-500 text-white text-sm rounded-lg hover:bg-red-600 transition"
                >
                  Abmelden
                </button>
              </div>
              
              <div className="relative">
                <input
                  type="text"
                  value={searchQuery}
                  onChange={(e) => {
                    setSearchQuery(e.target.value);
                    searchUsers(e.target.value);
                  }}
                  placeholder="Benutzer suchen..."
                  className="w-full pl-10 pr-4 py-2 bg-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <div className="absolute left-3 top-2.5">
                  <SearchIcon />
                </div>
              </div>
              
              {searchResults.length > 0 && (
                <div className="mt-2 bg-white border border-gray-200 rounded-lg shadow-lg max-h-48 overflow-y-auto">
                  {searchResults.map(user => (
                    <button
                      key={user}
                      onClick={() => startChat(user)}
                      className="w-full text-left px-4 py-3 hover:bg-blue-50 flex items-center justify-between border-b border-gray-100 last:border-0"
                    >
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                          {user[0].toUpperCase()}
                        </div>
                        <span className="font-medium">{user}</span>
                      </div>
                      {onlineUsers.includes(user) && (
                        <span className="w-3 h-3 bg-green-500 rounded-full"></span>
                      )}
                    </button>
                  ))}
                </div>
              )}
            </div>

            <div className="flex-1 overflow-y-auto">
              {chats.length === 0 ? (
                <div className="p-8 text-center text-gray-500">
                  <p className="mb-2">Noch keine Chats</p>
                  <p className="text-sm">Suche oben nach Benutzern</p>
                </div>
              ) : (
                chats.map(chatUser => (
                  <button
                    key={chatUser}
                    onClick={() => {
                      setCurrentChat(chatUser);
                      loadMessagesForChat(chatUser);
                    }}
                    className={`w-full text-left px-4 py-4 hover:bg-gray-50 border-b border-gray-100 transition ${
                      currentChat === chatUser ? 'bg-blue-50' : ''
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <div className="relative">
                        <div className="w-12 h-12 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-lg">
                          {chatUser[0].toUpperCase()}
                        </div>
                        {onlineUsers.includes(chatUser) && (
                          <span className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-white"></span>
                        )}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-semibold text-gray-900">{chatUser}</p>
                        <p className="text-sm text-gray-500 truncate">{getLastMessage(chatUser)}</p>
                      </div>
                    </div>
                  </button>
                ))
              )}
            </div>
          </div>

          {/* Chat-Bereich */}
          <div className="flex-1 flex flex-col">
            {currentChat ? (
              <>
                {/* Chat Header */}
                <div className="bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                      {currentChat[0].toUpperCase()}
                    </div>
                    <div>
                      <p className="font-semibold text-gray-900">{currentChat}</p>
                      <p className="text-sm text-gray-500">
                        {onlineUsers.includes(currentChat) ? 'Online' : 'Offline'}
                      </p>
                    </div>
                  </div>
                  <button
                    onClick={() => setCurrentChat(null)}
                    className="p-2 hover:bg-gray-100 rounded-full transition"
                  >
                    <XIcon />
                  </button>
                </div>

                {/* Nachrichten */}
                <div className="flex-1 overflow-y-auto p-6 bg-gray-50">
                  {(messages[currentChat] || []).length === 0 ? (
                    <div className="text-center text-gray-500 mt-20">
                      <p>Noch keine Nachrichten</p>
                      <p className="text-sm mt-2">Schreibe die erste Nachricht! ðŸ‘‹</p>
                    </div>
                  ) : (
                    (messages[currentChat] || []).map(msg => (
                      <div
                        key={msg.id}
                        className={`flex mb-4 ${msg.user === currentUser ? 'justify-end' : 'justify-start'}`}
                      >
                        <div className={`max-w-xs lg:max-w-md px-4 py-2 rounded-2xl ${
                          msg.user === currentUser
                            ? 'bg-blue-500 text-white rounded-br-none'
                            : 'bg-white text-gray-800 rounded-bl-none shadow'
                        }`}>
                          <p className="break-words whitespace-pre-wrap">{msg.text}</p>
                          <p className={`text-xs mt-1 ${msg.user === currentUser ? 'text-blue-100' : 'text-gray-500'}`}>
                            {new Date(msg.timestamp).toLocaleTimeString('de-DE', {
                              hour: '2-digit',
                              minute: '2-digit'
                            })}
                          </p>
                        </div>
                      </div>
                    ))
                  )}
                  <div ref={messagesEndRef} />
                </div>

                {/* Eingabebereich */}
                <div className="bg-white border-t border-gray-200 p-4">
                  {showEmojiPicker && (
                    <div className="mb-3 p-3 bg-gray-50 rounded-2xl flex flex-wrap gap-2">
                      {emojis.map((emoji, idx) => (
                        <button
                          key={idx}
                          onClick={() => addEmoji(emoji)}
                          className="text-2xl hover:scale-125 transition-transform"
                        >
                          {emoji}
                        </button>
                      ))}
                    </div>
                  )}
                  <div className="flex items-end gap-2">
                    <button
                      onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                      className="p-2 text-gray-500 hover:text-gray-700 transition"
                    >
                      <SmileIcon />
                    </button>
                    <button className="p-2 text-gray-500 hover:text-gray-700 transition">
                      <PaperclipIcon />
                    </button>
                    <textarea
                      value={message}
                      onChange={(e) => setMessage(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Nachricht..."
                      rows="1"
                      className="flex-1 px-4 py-2 border-2 border-gray-200 rounded-full focus:border-blue-500 focus:outline-none resize-none"
                      style={{ maxHeight: '100px' }}
                    />
                    <button
                      onClick={handleSendMessage}
                      className="p-3 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition shadow-lg"
                    >
                      <SendIcon />
                    </button>
                  </div>
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center bg-gray-50">
                <div className="text-center text-gray-500">
                  <div className="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mx-auto mb-4">
                    <svg className="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                  </div>
                  <h3 className="text-xl font-semibold mb-2">WÃ¤hle einen Chat</h3>
                  <p className="text-sm">Suche nach Benutzern oder wÃ¤hle einen bestehenden Chat</p>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.render(<EncryptedChat />, document.getElementById('root'));
  </script>
</body>
</html>
