<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sicherer Chat</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // WebSocket Setup
    let ws = null;
    
    const connectWebSocket = (onMessage) => {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}`);
      
      ws.onopen = () => console.log('‚úÖ WebSocket verbunden');
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        onMessage(data);
      };
      ws.onerror = (error) => console.error('‚ùå WebSocket Fehler:', error);
      ws.onclose = () => {
        console.log('üîÑ WebSocket getrennt, Reconnect in 3s...');
        setTimeout(() => connectWebSocket(onMessage), 3000);
      };
      
      return ws;
    };
    
    // Storage API
    window.storage = {
      async get(key, shared = false) {
        try {
          const response = await fetch(`/api/storage/${key}?shared=${shared}`);
          if (!response.ok) throw new Error('Key not found');
          return await response.json();
        } catch (e) {
          throw e;
        }
      },
      async set(key, value, shared = false) {
        const response = await fetch(`/api/storage/${key}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ value, shared })
        });
        return await response.json();
      }
    };

    // ============================================
    // üîê ECHTE WEB CRYPTO API VERSCHL√úSSELUNG
    // ============================================

    // Passwort zu AES Key ableiten (PBKDF2 mit 300.000 Iterationen)
    const deriveKeyFromPassword = async (password, salt) => {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw',
        enc.encode(password),
        'PBKDF2',
        false,
        ['deriveKey']
      );
      
      return await crypto.subtle.deriveKey(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: 300000,
          hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    };

    // RSA Keypair f√ºr jeden Benutzer erstellen
    const generateUserKeypair = async () => {
      return await crypto.subtle.generateKey(
        {
          name: 'RSA-OAEP',
          modulusLength: 2048,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: 'SHA-256'
        },
        true,
        ['encrypt', 'decrypt']
      );
    };

    // Private Key mit Passwort verschl√ºsseln
    const encryptPrivateKey = async (privateKey, password) => {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const key = await deriveKeyFromPassword(password, salt);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      
      const exported = await crypto.subtle.exportKey('pkcs8', privateKey);
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        exported
      );
      
      // Salt + IV + Encrypted zusammenpacken
      const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(new Uint8Array(encrypted), salt.length + iv.length);
      
      return btoa(String.fromCharCode(...result));
    };

    // Private Key mit Passwort entschl√ºsseln
    const decryptPrivateKey = async (encryptedData, password) => {
      const data = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
      const salt = data.slice(0, 16);
      const iv = data.slice(16, 28);
      const encrypted = data.slice(28);
      
      const key = await deriveKeyFromPassword(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        encrypted
      );
      
      return await crypto.subtle.importKey(
        'pkcs8',
        decrypted,
        { name: 'RSA-OAEP', hash: 'SHA-256' },
        true,
        ['decrypt']
      );
    };

    // Public Key exportieren
    const exportPublicKey = async (publicKey) => {
      const exported = await crypto.subtle.exportKey('spki', publicKey);
      return btoa(String.fromCharCode(...new Uint8Array(exported)));
    };

    // Public Key importieren
    const importPublicKey = async (keyData) => {
      const binary = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
      return await crypto.subtle.importKey(
        'spki',
        binary,
        { name: 'RSA-OAEP', hash: 'SHA-256' },
        true,
        ['encrypt']
      );
    };

    // Nachricht verschl√ºsseln (f√ºr einen Empf√§nger)
    const encryptMessage = async (text, recipientPublicKey) => {
      // 1. Session Key erstellen
      const sessionKey = await crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
      
      // 2. Nachricht mit Session Key verschl√ºsseln
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        sessionKey,
        enc.encode(text)
      );
      
      // 3. Session Key exportieren und mit Public Key verschl√ºsseln
      const exportedSessionKey = await crypto.subtle.exportKey('raw', sessionKey);
      const encryptedSessionKey = await crypto.subtle.encrypt(
        { name: 'RSA-OAEP' },
        recipientPublicKey,
        exportedSessionKey
      );
      
      return {
        ciphertext: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
        iv: btoa(String.fromCharCode(...iv)),
        encryptedSessionKey: btoa(String.fromCharCode(...new Uint8Array(encryptedSessionKey)))
      };
    };

    // Nachricht entschl√ºsseln
    const decryptMessage = async (encrypted, privateKey) => {
      try {
        // 1. Session Key entschl√ºsseln
        const encryptedSessionKeyData = Uint8Array.from(atob(encrypted.encryptedSessionKey), c => c.charCodeAt(0));
        const sessionKeyData = await crypto.subtle.decrypt(
          { name: 'RSA-OAEP' },
          privateKey,
          encryptedSessionKeyData
        );
        
        // 2. Session Key importieren
        const sessionKey = await crypto.subtle.importKey(
          'raw',
          sessionKeyData,
          { name: 'AES-GCM', length: 256 },
          false,
          ['decrypt']
        );
        
        // 3. Nachricht entschl√ºsseln
        const iv = Uint8Array.from(atob(encrypted.iv), c => c.charCodeAt(0));
        const ciphertext = Uint8Array.from(atob(encrypted.ciphertext), c => c.charCodeAt(0));
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv },
          sessionKey,
          ciphertext
        );
        
        return new TextDecoder().decode(decrypted);
      } catch (e) {
        console.error('Entschl√ºsselung fehlgeschlagen:', e);
        return '[Entschl√ºsselung fehlgeschlagen]';
      }
    };

    // Icons
    const LockIcon = () => (
      <svg className="w-12 h-12 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
      </svg>
    );

    const SendIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
      </svg>
    );

    const SearchIcon = () => (
      <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    );

    const XIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    );

    const SmileIcon = () => (
      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    );

    const CheckIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
      </svg>
    );

    const SettingsIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
    );

    const TrashIcon = () => (
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
      </svg>
    );

    const EncryptedChat = () => {
      const [isLoggedIn, setIsLoggedIn] = useState(false);
      const [username, setUsername] = useState('');
      const [password, setPassword] = useState('');
      const [currentUser, setCurrentUser] = useState('');
      const [privateKey, setPrivateKey] = useState(null);
      const [currentChat, setCurrentChat] = useState(null);
      const [message, setMessage] = useState('');
      const [chats, setChats] = useState([]);
      const [messages, setMessages] = useState({});
      const [error, setError] = useState('');
      const [onlineUsers, setOnlineUsers] = useState([]);
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);
      const [showEmojiPicker, setShowEmojiPicker] = useState(false);
      const [chatRequests, setChatRequests] = useState([]);
      const [pendingRequests, setPendingRequests] = useState([]);
      const [selectedMessage, setSelectedMessage] = useState(null);
      const [typingUsers, setTypingUsers] = useState({});
      const [showSettings, setShowSettings] = useState(false);
      const messagesEndRef = useRef(null);
      const wsRef = useRef(null);

      const emojis = ['üòÄ', 'üòÇ', 'üòç', 'ü•∞', 'üòé', 'ü§î', 'üëç', 'üëè', 'üéâ', '‚ù§Ô∏è', 'üî•', '‚ú®', 'üíØ', 'üöÄ', '‚≠ê', 'üí™'];
      const reactionEmojis = ['‚ù§Ô∏è', 'üòÇ', 'üëç', 'üî•', 'üéâ', 'üòÆ'];

      useEffect(() => {
        loadUserData();
        
        wsRef.current = connectWebSocket((data) => {
          if (data.type === 'users_update') {
            setOnlineUsers(data.users);
          }
          if (data.type === 'new_message') {
            if (currentChat) loadMessagesForChat(currentChat);
          }
          if (data.type === 'chat_request' || data.type === 'chat_accepted') {
            loadChatRequests();
            loadUserData();
          }
          if (data.type === 'typing' && data.chat === currentChat && data.user !== currentUser) {
            setTypingUsers(prev => ({ ...prev, [data.user]: true }));
            setTimeout(() => {
              setTypingUsers(prev => {
                const newTyping = { ...prev };
                delete newTyping[data.user];
                return newTyping;
              });
            }, 3000);
          }
        });

        ws = wsRef.current;

        return () => {
          if (wsRef.current) {
            if (currentUser) {
              wsRef.current.send(JSON.stringify({ type: 'user_offline', username: currentUser }));
            }
            wsRef.current.close();
          }
        };
      }, []);

      useEffect(() => {
        if (isLoggedIn && wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ type: 'user_online', username: currentUser }));
        }
      }, [isLoggedIn, currentUser]);

      useEffect(() => {
        if (currentChat) {
          loadMessagesForChat(currentChat);
          
          // Nachrichten alle 2 Sekunden neu laden f√ºr Live-Updates
          const interval = setInterval(() => {
            loadMessagesForChat(currentChat);
          }, 2000);
          
          return () => clearInterval(interval);
        }
      }, [currentChat]);

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages, currentChat]);

      useEffect(() => {
        if (isLoggedIn && currentUser) {
          loadUserData();
          loadChatRequests();
          
          // Regelm√§√üig nach neuen Anfragen suchen
          const interval = setInterval(() => {
            loadChatRequests();
          }, 3000);
          
          return () => clearInterval(interval);
        }
      }, [isLoggedIn, currentUser]);

      const loadUserData = async () => {
        if (!currentUser) return;
        try {
          const result = await window.storage.get('chats_' + currentUser, true);
          setChats(JSON.parse(result.value));
        } catch (e) {
          setChats([]);
        }
      };

      const loadChatRequests = async () => {
        if (!currentUser) return;
        try {
          const result = await window.storage.get('requests_' + currentUser, true);
          setChatRequests(JSON.parse(result.value));
        } catch (e) {
          setChatRequests([]);
        }

        try {
          const result = await window.storage.get('pending_' + currentUser, true);
          setPendingRequests(JSON.parse(result.value));
        } catch (e) {
          setPendingRequests([]);
        }
      };

      const loadMessagesForChat = async (chatUser) => {
        if (!chatUser || !privateKey) return;
        
        const chatId = [currentUser, chatUser].sort().join('_');
        try {
          const result = await window.storage.get(`messages_${chatId}`, true);
          const encryptedMessages = JSON.parse(result.value);
          
          const decryptedMessages = await Promise.all(
            encryptedMessages.map(async msg => ({
              ...msg,
              text: await decryptMessage(msg.encryptedData, privateKey)
            }))
          );
          
          setMessages(prev => ({ ...prev, [chatUser]: decryptedMessages }));
        } catch (e) {
          setMessages(prev => ({ ...prev, [chatUser]: [] }));
        }
      };

      const handleAuth = async () => {
        setError('');
        if (!username || !password) {
          setError('Bitte beide Felder ausf√ºllen');
          return;
        }

        if (username.length < 3 || password.length < 6) {
          setError('Username min. 3, Passwort min. 6 Zeichen');
          return;
        }

        try {
          let userData = {};
          try {
            const result = await window.storage.get('userdata_' + username, true);
            userData = JSON.parse(result.value);
          } catch (e) {
            // Neuer Benutzer - Keypair erstellen
            const keypair = await generateUserKeypair();
            const encryptedPrivKey = await encryptPrivateKey(keypair.privateKey, password);
            const publicKey = await exportPublicKey(keypair.publicKey);
            
            userData = {
              encryptedPrivateKey: encryptedPrivKey,
              publicKey: publicKey
            };
            
            await window.storage.set('userdata_' + username, JSON.stringify(userData), true);
          }

          // Private Key entschl√ºsseln
          try {
            const privKey = await decryptPrivateKey(userData.encryptedPrivateKey, password);
            setPrivateKey(privKey);
            setCurrentUser(username);
            setIsLoggedIn(true);
            
            // Benutzer in der globalen Benutzerliste registrieren
            let allUsers = [];
            try {
              const usersResult = await window.storage.get('all_users', true);
              allUsers = JSON.parse(usersResult.value);
            } catch (e) {
              allUsers = [];
            }
            
            if (!allUsers.includes(username)) {
              allUsers.push(username);
              await window.storage.set('all_users', JSON.stringify(allUsers), true);
            }
            
            await loadUserData();
            await loadChatRequests();
          } catch (e) {
            setError('Falsches Passwort');
          }
        } catch (e) {
          setError('Fehler: ' + e.message);
        }
      };

      const searchUsers = async (query) => {
        setSearchQuery(query);
        
        if (!query || query.trim().length === 0) {
          setSearchResults([]);
          return;
        }

        try {
          // Hole alle registrierten Benutzer aus der globalen Liste
          let allUsers = [];
          try {
            const usersResult = await window.storage.get('all_users', true);
            allUsers = JSON.parse(usersResult.value);
          } catch (e) {
            allUsers = [];
          }
          
          console.log('Alle Benutzer:', allUsers);
          
          // Suche nach √úbereinstimmung
          const matchedUsers = allUsers.filter(u => 
            u.toLowerCase().includes(query.toLowerCase())
          );
          
          console.log('√úbereinstimmende Benutzer:', matchedUsers);
          
          // Filtere den aktuellen Benutzer und bereits verbundene aus
          const filteredUsers = matchedUsers.filter(u => {
            const isNotSelf = u !== currentUser;
            const notInChats = !chats.includes(u);
            const notInRequests = !chatRequests.includes(u);
            const notInPending = !pendingRequests.includes(u);
            
            return isNotSelf && notInChats && notInRequests && notInPending;
          });
          
          console.log('Gefilterte Benutzer:', filteredUsers);
          setSearchResults(filteredUsers);
          
        } catch (e) {
          console.error('Suchfehler:', e);
          setSearchResults([]);
        }
      };

      const sendChatRequest = async (targetUser) => {
        try {
          let theirRequests = [];
          try {
            const result = await window.storage.get('requests_' + targetUser, true);
            theirRequests = JSON.parse(result.value);
          } catch (e) {
            theirRequests = [];
          }

          if (!theirRequests.includes(currentUser)) {
            theirRequests.push(currentUser);
            await window.storage.set('requests_' + targetUser, JSON.stringify(theirRequests), true);
          }

          let myPending = pendingRequests;
          if (!myPending.includes(targetUser)) {
            myPending = [...myPending, targetUser];
            setPendingRequests(myPending);
            await window.storage.set('pending_' + currentUser, JSON.stringify(myPending), true);
          }

          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'chat_request', to: targetUser }));
          }

          setSearchQuery('');
          setSearchResults([]);
          setError('');
        } catch (e) {
          setError('Fehler beim Senden der Anfrage');
        }
      };

      const acceptChatRequest = async (requester) => {
        try {
          // F√ºge Requester zu meinen Chats hinzu
          const newChats = [...chats, requester];
          setChats(newChats);
          await window.storage.set('chats_' + currentUser, JSON.stringify(newChats), true);

          // F√ºge mich zu deren Chats hinzu
          let theirChats = [];
          try {
            const result = await window.storage.get('chats_' + requester, true);
            theirChats = JSON.parse(result.value);
          } catch (e) {
            theirChats = [];
          }

          if (!theirChats.includes(currentUser)) {
            theirChats.push(currentUser);
            await window.storage.set('chats_' + requester, JSON.stringify(theirChats), true);
          }

          // Entferne aus Anfragen
          const newRequests = chatRequests.filter(r => r !== requester);
          setChatRequests(newRequests);
          await window.storage.set('requests_' + currentUser, JSON.stringify(newRequests), true);

          // Entferne aus deren Pending-Liste
          try {
            const theirPendingResult = await window.storage.get('pending_' + requester, true);
            let theirPending = JSON.parse(theirPendingResult.value);
            theirPending = theirPending.filter(p => p !== currentUser);
            await window.storage.set('pending_' + requester, JSON.stringify(theirPending), true);
          } catch (e) {
            // Kein Problem wenn nicht vorhanden
          }

          setCurrentChat(requester);
          await loadMessagesForChat(requester);
          
          // Sende Benachrichtigung √ºber WebSocket
          if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({ 
              type: 'chat_accepted', 
              from: currentUser,
              to: requester 
            }));
          }
        } catch (e) {
          setError('Fehler beim Akzeptieren: ' + e.message);
        }
      };

      const declineChatRequest = async (requester) => {
        try {
          const newRequests = chatRequests.filter(r => r !== requester);
          setChatRequests(newRequests);
          await window.storage.set('requests_' + currentUser, JSON.stringify(newRequests), true);
        } catch (e) {
          setError('Fehler beim Ablehnen');
        }
      };

      const handleSendMessage = async () => {
        if (!message.trim() || !currentChat || !privateKey) return;

        try {
          // Public Key des Empf√§ngers laden
          const recipientData = await window.storage.get('userdata_' + currentChat, true);
          const recipientPublicKey = await importPublicKey(JSON.parse(recipientData.value).publicKey);

          // Nachricht verschl√ºsseln
          const encrypted = await encryptMessage(message, recipientPublicKey);

          const newMessage = {
            id: Date.now(),
            user: currentUser,
            encryptedData: encrypted,
            reactions: {},
            timestamp: new Date().toISOString()
          };

          const chatId = [currentUser, currentChat].sort().join('_');
          let existingMessages = [];
          
          try {
            const result = await window.storage.get(`messages_${chatId}`, true);
            existingMessages = JSON.parse(result.value);
          } catch (e) {
            existingMessages = [];
          }
          
          existingMessages.push(newMessage);
          await window.storage.set(`messages_${chatId}`, JSON.stringify(existingMessages), true);
          
          if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({ type: 'new_message', chat: chatId }));
          }
          
          await loadMessagesForChat(currentChat);
          setMessage('');
          setShowEmojiPicker(false);
        } catch (e) {
          setError('Fehler beim Senden: ' + e.message);
        }
      };

      const addReaction = async (messageId, emoji) => {
        if (!currentChat) return;

        try {
          const chatId = [currentUser, currentChat].sort().join('_');
          const result = await window.storage.get(`messages_${chatId}`, true);
          let allMessages = JSON.parse(result.value);

          const msgIndex = allMessages.findIndex(m => m.id === messageId);
          if (msgIndex !== -1) {
            if (!allMessages[msgIndex].reactions) {
              allMessages[msgIndex].reactions = {};
            }
            if (!allMessages[msgIndex].reactions[emoji]) {
              allMessages[msgIndex].reactions[emoji] = [];
            }
            
            const userIndex = allMessages[msgIndex].reactions[emoji].indexOf(currentUser);
            if (userIndex === -1) {
              allMessages[msgIndex].reactions[emoji].push(currentUser);
            } else {
              allMessages[msgIndex].reactions[emoji].splice(userIndex, 1);
              if (allMessages[msgIndex].reactions[emoji].length === 0) {
                delete allMessages[msgIndex].reactions[emoji];
              }
            }

            await window.storage.set(`messages_${chatId}`, JSON.stringify(allMessages), true);
            await loadMessagesForChat(currentChat);
          }
        } catch (e) {
          console.error('Fehler beim Reagieren:', e);
        }
        
        setSelectedMessage(null);
      };

      const handleLogout = () => {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ type: 'user_offline', username: currentUser }));
        }
        setIsLoggedIn(false);
        setCurrentUser('');
        setCurrentChat(null);
        setMessages({});
        setChats([]);
        setPassword('');
        setPrivateKey(null);
        setShowSettings(false);
      };

      const handleKeyPress = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (currentChat) {
            handleSendMessage();
          } else {
            handleAuth();
          }
        }
      };

      const handleTyping = () => {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN && currentChat) {
          const chatId = [currentUser, currentChat].sort().join('_');
          wsRef.current.send(JSON.stringify({ 
            type: 'typing', 
            chat: chatId, 
            user: currentUser 
          }));
        }
      };

      const deleteAccount = async () => {
        if (!confirm('M√∂chtest du deinen Account wirklich l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden!')) {
          return;
        }

        try {
          // Alle Benutzerdaten l√∂schen
          await window.storage.set('userdata_' + currentUser, JSON.stringify({}), true);
          await window.storage.set('chats_' + currentUser, JSON.stringify([]), true);
          await window.storage.set('requests_' + currentUser, JSON.stringify([]), true);
          await window.storage.set('pending_' + currentUser, JSON.stringify([]), true);

          // Logout
          handleLogout();
          alert('Account wurde gel√∂scht');
        } catch (e) {
          setError('Fehler beim L√∂schen des Accounts: ' + e.message);
        }
      };

      const addEmoji = (emoji) => {
        setMessage(message + emoji);
      };

      const getLastMessage = (chatUser) => {
        const msgs = messages[chatUser] || [];
        if (msgs.length === 0) return 'Noch keine Nachrichten';
        const last = msgs[msgs.length - 1];
        return last.text.substring(0, 30) + (last.text.length > 30 ? '...' : '');
      };

      if (!isLoggedIn) {
        return (
          <div className="h-screen bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center p-4">
            <div className="bg-white rounded-3xl shadow-2xl p-8 w-full max-w-md">
              <div className="flex items-center justify-center mb-6">
                <LockIcon />
              </div>
              <h1 className="text-3xl font-bold text-center mb-2 text-gray-800">Sicherer Chat</h1>
              <p className="text-center text-gray-600 mb-2">Ende-zu-Ende verschl√ºsselt</p>
              <p className="text-center text-xs text-gray-500 mb-8">RSA-2048 + AES-256-GCM</p>
              
              <div className="space-y-4">
                <input
                  type="text"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                  placeholder="Benutzername (min. 3 Zeichen)"
                />
                
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  onKeyPress={handleKeyPress}
                  className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                  placeholder="Passwort (min. 6 Zeichen)"
                />

                {error && (
                  <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl text-sm">
                    {error}
                  </div>
                )}

                <button
                  onClick={handleAuth}
                  className="w-full bg-blue-500 text-white py-3 rounded-xl font-semibold hover:bg-blue-600 transition shadow-lg"
                >
                  Anmelden / Registrieren
                </button>
              </div>

              <p className="text-xs text-gray-500 text-center mt-6">
                Server kann Nachrichten nicht lesen
              </p>
            </div>
          </div>
        );
      }

      return (
        <div className="h-screen flex bg-gray-100">
          {/* Sidebar */}
          <div className="w-80 bg-white border-r border-gray-200 flex flex-col">
            <div className="p-4 border-b border-gray-200 bg-white">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold text-gray-800">Nachrichten</h2>
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowSettings(!showSettings)}
                    className="p-2 hover:bg-gray-100 rounded-lg transition"
                    title="Einstellungen"
                  >
                    <SettingsIcon />
                  </button>
                  <button
                    onClick={handleLogout}
                    className="px-3 py-1 bg-red-500 text-white text-sm rounded-lg hover:bg-red-600 transition"
                  >
                    Abmelden
                  </button>
                </div>
              </div>

              {showSettings && (
                <div className="mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                  <h3 className="font-semibold text-gray-800 mb-3">Einstellungen</h3>
                  <div className="space-y-2">
                    <div className="text-sm text-gray-600">
                      <p><strong>Benutzername:</strong> {currentUser}</p>
                      <p><strong>Status:</strong> <span className="text-green-600">‚óè Online</span></p>
                    </div>
                    <button
                      onClick={deleteAccount}
                      className="w-full flex items-center justify-center gap-2 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition"
                    >
                      <TrashIcon />
                      Account l√∂schen
                    </button>
                  </div>
                </div>
              )}
              
              <div className="relative">
                <input
                  type="text"
                  value={searchQuery}
                  onChange={(e) => searchUsers(e.target.value)}
                  placeholder="Benutzer suchen..."
                  className="w-full pl-10 pr-4 py-2 bg-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <div className="absolute left-3 top-2.5">
                  <SearchIcon />
                </div>
              </div>
              
              {searchQuery && searchQuery.trim().length > 0 && (
                <div className="mt-2 bg-white border border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto">
                  {searchResults.length === 0 ? (
                    <div className="px-4 py-3 text-center text-gray-500 text-sm">
                      Keine Benutzer gefunden
                    </div>
                  ) : (
                    searchResults.map(user => (
                      <button
                        key={user}
                        onClick={() => sendChatRequest(user)}
                        className="w-full text-left px-4 py-3 hover:bg-blue-50 flex items-center justify-between border-b border-gray-100 last:border-0"
                      >
                        <div className="flex items-center gap-3">
                          <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                            {user[0].toUpperCase()}
                          </div>
                          <div>
                            <span className="font-medium">{user}</span>
                            {pendingRequests.includes(user) && (
                              <span className="text-xs text-gray-500"> (Anfrage gesendet)</span>
                            )}
                          </div>
                        </div>
                        {onlineUsers.includes(user) && (
                          <span className="w-3 h-3 bg-green-500 rounded-full"></span>
                        )}
                      </button>
                    ))
                  )}
                </div>
              )}
            </div>

            {chatRequests.length > 0 && (
              <div className="bg-blue-50 border-b border-blue-200 p-3">
                <p className="text-sm font-semibold text-blue-900 mb-2">Chat-Anfragen ({chatRequests.length})</p>
                {chatRequests.map(requester => (
                  <div key={requester} className="bg-white rounded-lg p-3 mb-2 flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <div className="w-8 h-8 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                        {requester[0].toUpperCase()}
                      </div>
                      <span className="font-medium text-sm">{requester}</span>
                    </div>
                    <div className="flex gap-1">
                      <button
                        onClick={() => acceptChatRequest(requester)}
                        className="p-1 bg-green-500 text-white rounded hover:bg-green-600"
                      >
                        <CheckIcon />
                      </button>
                      <button
                        onClick={() => declineChatRequest(requester)}
                        className="p-1 bg-red-500 text-white rounded hover:bg-red-600"
                      >
                        <XIcon />
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}

            <div className="flex-1 overflow-y-auto">
              {chats.length === 0 ? (
                <div className="p-8 text-center text-gray-500">
                  <p className="mb-2">Noch keine Chats</p>
                  <p className="text-sm">Suche oben nach Benutzern</p>
                </div>
              ) : (
                chats.map(chatUser => (
                  <button
                    key={chatUser}
                    onClick={() => {
                      setCurrentChat(chatUser);
                      loadMessagesForChat(chatUser);
                    }}
                    className={`w-full text-left px-4 py-4 hover:bg-gray-50 border-b border-gray-100 transition ${
                      currentChat === chatUser ? 'bg-blue-50' : ''
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <div className="relative">
                        <div className="w-12 h-12 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-lg">
                          {chatUser[0].toUpperCase()}
                        </div>
                        {onlineUsers.includes(chatUser) && (
                          <span className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-white"></span>
                        )}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-semibold text-gray-900">{chatUser}</p>
                        <p className="text-sm text-gray-500 truncate">{getLastMessage(chatUser)}</p>
                      </div>
                    </div>
                  </button>
                ))
              )}
            </div>
          </div>

          {/* Chat-Bereich */}
          <div className="flex-1 flex flex-col">
            {currentChat ? (
              <>
                <div className="bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold">
                      {currentChat[0].toUpperCase()}
                    </div>
                    <div>
                      <p className="font-semibold text-gray-900">{currentChat}</p>
                      <p className="text-sm text-gray-500">
                        {typingUsers[currentChat] ? 'tippt...' : onlineUsers.includes(currentChat) ? 'Online' : 'Offline'}
                      </p>
                    </div>
                  </div>
                  <button
                    onClick={() => setCurrentChat(null)}
                    className="p-2 hover:bg-gray-100 rounded-full transition"
                  >
                    <XIcon />
                  </button>
                </div>

                <div className="flex-1 overflow-y-auto p-6 bg-gray-50">
                  {(messages[currentChat] || []).length === 0 ? (
                    <div className="text-center text-gray-500 mt-20">
                      <p>Noch keine Nachrichten</p>
                      <p className="text-sm mt-2">Schreibe die erste Nachricht! üëã</p>
                    </div>
                  ) : (
                    (messages[currentChat] || []).map(msg => (
                      <div
                        key={msg.id}
                        className={`flex mb-4 ${msg.user === currentUser ? 'justify-end' : 'justify-start'}`}
                      >
                        <div className="relative">
                          <div 
                            className={`max-w-xs lg:max-w-md px-4 py-2 rounded-2xl cursor-pointer ${
                              msg.user === currentUser
                                ? 'bg-blue-500 text-white rounded-br-none'
                                : 'bg-white text-gray-800 rounded-bl-none shadow'
                            }`}
                            onContextMenu={(e) => {
                              e.preventDefault();
                              setSelectedMessage(msg.id);
                            }}
                            onClick={() => setSelectedMessage(msg.id === selectedMessage ? null : msg.id)}
                          >
                            <p className="break-words whitespace-pre-wrap">{msg.text}</p>
                            <p className={`text-xs mt-1 ${msg.user === currentUser ? 'text-blue-100' : 'text-gray-500'}`}>
                              {new Date(msg.timestamp).toLocaleTimeString('de-DE', {
                                hour: '2-digit',
                                minute: '2-digit'
                              })}
                            </p>
                            
                            {msg.reactions && Object.keys(msg.reactions).length > 0 && (
                              <div className="flex gap-1 mt-2 flex-wrap">
                                {Object.entries(msg.reactions).map(([emoji, users]) => (
                                  users.length > 0 && (
                                    <span 
                                      key={emoji}
                                      className="bg-white bg-opacity-20 rounded-full px-2 py-0.5 text-sm flex items-center gap-1"
                                    >
                                      {emoji} {users.length}
                                    </span>
                                  )
                                ))}
                              </div>
                            )}
                          </div>

                          {selectedMessage === msg.id && (
                            <div className="absolute bottom-full mb-2 bg-white rounded-lg shadow-lg p-2 flex gap-2 z-10">
                              {reactionEmojis.map(emoji => (
                                <button
                                  key={emoji}
                                  onClick={() => addReaction(msg.id, emoji)}
                                  className="text-2xl hover:scale-125 transition-transform"
                                >
                                  {emoji}
                                </button>
                              ))}
                            </div>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                  <div ref={messagesEndRef} />
                </div>

                <div className="bg-white border-t border-gray-200 p-4">
                  {showEmojiPicker && (
                    <div className="mb-3 p-3 bg-gray-50 rounded-2xl flex flex-wrap gap-2">
                      {emojis.map((emoji, idx) => (
                        <button
                          key={idx}
                          onClick={() => addEmoji(emoji)}
                          className="text-2xl hover:scale-125 transition-transform"
                        >
                          {emoji}
                        </button>
                      ))}
                    </div>
                  )}
                  <div className="flex items-end gap-2">
                    <button
                      onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                      className="p-2 text-gray-500 hover:text-gray-700 transition"
                    >
                      <SmileIcon />
                    </button>
                    <textarea
                      value={message}
                      onChange={(e) => {
                        setMessage(e.target.value);
                        handleTyping();
                      }}
                      onKeyPress={handleKeyPress}
                      placeholder="Nachricht..."
                      rows="1"
                      className="flex-1 px-4 py-2 border-2 border-gray-200 rounded-full focus:border-blue-500 focus:outline-none resize-none"
                      style={{ maxHeight: '100px' }}
                    />
                    <button
                      onClick={handleSendMessage}
                      className="p-3 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition shadow-lg"
                    >
                      <SendIcon />
                    </button>
                  </div>
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center bg-gray-50">
                <div className="text-center text-gray-500">
                  <div className="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mx-auto mb-4">
                    <svg className="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                    </svg>
                  </div>
                  <h3 className="text-xl font-semibold mb-2">W√§hle einen Chat</h3>
                  <p className="text-sm">Suche nach Benutzern oder w√§hle einen bestehenden Chat</p>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.render(<EncryptedChat />, document.getElementById('root'));
  </script>
</body>
</html>
